<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo主题自定义与美化</title>
    <url>/2022/10/12/change-theme/</url>
    <content><![CDATA[<h2 id="粒子时钟"><a href="#粒子时钟" class="headerlink" title="粒子时钟"></a>粒子时钟</h2><p><a href="https://tding.top/archives/dd68b70.html">https://tding.top/archives/dd68b70.html</a></p>
<h2 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h2><p>在hexo根目录下执行命令添加依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>



<p>然后在自定义主题的_config.yml文件下将local_search改为true</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># unescape html strings to the readable one</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>





<h2 id="动态背景"><a href="#动态背景" class="headerlink" title="动态背景"></a>动态背景</h2><p>将下列的其中一个改为true即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<span id="more"></span>



<h2 id="添加菜单menu"><a href="#添加菜单menu" class="headerlink" title="添加菜单menu"></a>添加菜单menu</h2><p>首先在根目录下使用<code>hexo new page about</code>创建about页面，其他的以此类推。</p>
<p>然后再index.md文件里加上type,</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2022-10-13 00:38:31</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;about&quot;</span></span><br></pre></td></tr></table></figure>





<h2 id="阅读更多-x2F-阅读全文"><a href="#阅读更多-x2F-阅读全文" class="headerlink" title="阅读更多&#x2F;阅读全文"></a>阅读更多&#x2F;阅读全文</h2><p>在写文章时通过 <!-- more --> 手动截断</p>
<p>修改主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>



<h2 id="文章阅读数量统计"><a href="#文章阅读数量统计" class="headerlink" title="文章阅读数量统计"></a>文章阅读数量统计</h2><p><a href="https://albenw.github.io/posts/be8242cc/">https://albenw.github.io/posts/be8242cc/</a></p>
<h2 id="滚动进度条"><a href="#滚动进度条" class="headerlink" title="滚动进度条"></a>滚动进度条</h2><p>修改主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line"> <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>





<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>在网站根目录的_config.yml下修改下面的每页文章数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title>记录Hexo建站遇到的问题</title>
    <url>/2022/10/12/issues-md/</url>
    <content><![CDATA[<h1 id="Hexo建站遇到的issue"><a href="#Hexo建站遇到的issue" class="headerlink" title="Hexo建站遇到的issue"></a>Hexo建站遇到的issue</h1><h2 id="Git-error-RPC-failed；-curl-28-OpenSSL-SSL-read"><a href="#Git-error-RPC-failed；-curl-28-OpenSSL-SSL-read" class="headerlink" title="Git error: RPC failed； curl 28 OpenSSL SSL_read"></a>Git error: RPC failed； curl 28 OpenSSL SSL_read</h2><p>RPC远程过程调用失败，SSL证书验证失败，可以通过git config取消SSL验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify <span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="遇到-‘fatal-unable-to-access-‘https-XXX-Failed-onnect-to-github-com-port-443-Timed-out"><a href="#遇到-‘fatal-unable-to-access-‘https-XXX-Failed-onnect-to-github-com-port-443-Timed-out" class="headerlink" title="遇到 ‘fatal: unable to access ‘https://XXX: Failed onnect to github. com port 443: Timed out"></a>遇到 ‘fatal: unable to access ‘<a href="https://xxx/">https://XXX</a>: Failed onnect to github. com port 443: Timed out</h2><p>这是因为我们开着VPN代理，解决方法如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br></pre></td></tr></table></figure>

<p>如果还不能解决，试下关掉代理，再执行这个命令。</p>
<h2 id="更换主题时，输入URL出现下面的一串"><a href="#更换主题时，输入URL出现下面的一串" class="headerlink" title="更换主题时，输入URL出现下面的一串"></a>更换主题时，输入URL出现下面的一串</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;“</span><br></pre></td></tr></table></figure>





<p>这个问题是Hexo 5.0后把swig删除了，我们需要手动安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure>



<span id="more"></span>



<h2 id="菜单页的about，home这些页面点击会出现404"><a href="#菜单页的about，home这些页面点击会出现404" class="headerlink" title="菜单页的about，home这些页面点击会出现404"></a>菜单页的about，home这些页面点击会出现404</h2><p>我们会发现虽然使用hexo new page about新建了之后还是404，而且每个请求后面都有<code>20%</code>。那是因为menu下有空格，只需要删除 <code>||</code> 前面的空格即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives||</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>





<h2 id="next主题点击post时会出现-cannot-get-archives-7C-7C-20archive"><a href="#next主题点击post时会出现-cannot-get-archives-7C-7C-20archive" class="headerlink" title="next主题点击post时会出现 cannot get archives%7C%7C%20archive"></a>next主题点击post时会出现 cannot get archives%7C%7C%20archive</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>首先我们要知道 %7C是|的编码，%20是空格的编码<br>所以上面的报错实际上是<br>cannot get archives|| archive</p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>所以这里就有了第一个解决方法<br>把最后一行改为archives: &#x2F;archives&#x2F;即删掉后面的部分，但是这种方法很明显有问题<br>因为|| archive是一种格式，后面表示的是图标，删掉的话你的博客里面的“归档”就没有图标了</p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><h2 id="修改主题样式本地生效，但是网站不生效"><a href="#修改主题样式本地生效，但是网站不生效" class="headerlink" title="修改主题样式本地生效，但是网站不生效"></a>修改主题样式本地生效，但是网站不生效</h2><p>将主题改成下面的样式后，网站不生效。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<p>在根目录下面执行命令，清除缓存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo c</span><br></pre></td></tr></table></figure>

<p>还不生效的话就需要清除浏览器的缓存了，因为静态文件的连接还保存在浏览器里。</p>
<p>生成效果可以使用浏览器的无痕模式查看，或者更换浏览器(因为更换浏览器没有之前的缓存)，就会发现生效了。</p>
<p>如果不手动删除的话有可能需要等几个小时才会生效，这个其实是缓存的TTL到了存活时间限制，然后被自动删除了。</p>
<h2 id="next主题分页图标问题："><a href="#next主题分页图标问题：" class="headerlink" title="next主题分页图标问题："></a>next主题分页图标问题：<i class="fa fa-angle-right"></i></h2><p>​	</p>
<p>将该位置的代码<code>themes\next\layout\_partials\pagination.swig</code>，改成下面的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">%</span> <span class="string">if</span> <span class="string">page.prev</span> <span class="string">or</span> <span class="string">page.next</span> <span class="string">%</span>&#125;</span><br><span class="line">  <span class="string">&lt;nav</span> <span class="string">class=&quot;pagination&quot;&gt;</span></span><br><span class="line">    &#123;&#123;</span><br><span class="line">      <span class="string">paginator(</span>&#123;</span><br><span class="line">        <span class="attr">prev_text:</span> <span class="string">&#x27;&lt;&#x27;</span>,</span><br><span class="line">        <span class="attr">next_text:</span> <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">        <span class="attr">mid_size:</span> <span class="number">1</span></span><br><span class="line">      &#125;<span class="string">)</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  <span class="string">&lt;/nav&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">endif</span> <span class="string">%</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Template-render-error-unknown-path"><a href="#Template-render-error-unknown-path" class="headerlink" title="Template render error: (unknown path)"></a>Template render error: (unknown path)</h2><p>出现这个的问题是Hexo对于下列字符无法转义，要么删掉这些符号，要么使用&#96;&#96;对它们进行转义。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;，&#123;% %&#125;</span><br></pre></td></tr></table></figure>



<h2 id="本地预览正常，但是网站没有更新文章"><a href="#本地预览正常，但是网站没有更新文章" class="headerlink" title="本地预览正常，但是网站没有更新文章"></a>本地预览正常，但是网站没有更新文章</h2><p>进入_config.yml文件，然后将url改成自己网站的,下面是我改完后的示例。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://fool-cats.github.io/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="spawn-failed："><a href="#spawn-failed：" class="headerlink" title="spawn failed："></a>spawn failed：</h2><ol>
<li>删除<code>.deploy_git</code>文件夹;</li>
<li>输入<code>git config --global core.autocrlf false</code></li>
<li>然后，依次执行：<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo d</code></li>
</ol>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Problem</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8</title>
    <url>/2022/10/13/Java-8/</url>
    <content><![CDATA[<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><blockquote>
<p>Don’t need to store all values of a collection to process data, we can process data while storing data.</p>
</blockquote>
<p>A <em>Stream in Java</em> can be defined as a <strong>sequence of elements from a source</strong>, such as arrays, <em>List</em>, <em>Set</em> or any other collection.</p>
<p>Streams are &#x3D;&#x3D;lazily operated&#x3D;&#x3D;, opposite to collections that must store all the values before it starts processing. <strong>Stream is conceptually a pipeline, in which elements are computed on demand</strong>.</p>
<p><strong>a stream is</strong> :</p>
<ul>
<li>Not a data structure</li>
<li>Designed for <a href="https://howtodoinjava.com/java8/lambda-expressions/">lambdas</a></li>
<li>Do not support indexed access</li>
<li>Can easily be aggregated as arrays or lists</li>
<li>Lazy access supported</li>
<li>Parallelizable</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一下如何将本地的Spring Boot应用连接到Docker中的Mongodb</title>
    <url>/2022/10/13/spring-boot-and-mongodb/</url>
    <content><![CDATA[<h1 id="Spring-Boot和Mongodb整合"><a href="#Spring-Boot和Mongodb整合" class="headerlink" title="Spring Boot和Mongodb整合"></a>Spring Boot和Mongodb整合</h1><p>最近学习微服务的时候用到了本地的Spring boot和远程的Docker容器,查了一些资料</p>
<h2 id="在docker上使用mongodb-不整合spring-boot"><a href="#在docker上使用mongodb-不整合spring-boot" class="headerlink" title="在docker上使用mongodb(不整合spring boot)"></a>在docker上使用mongodb(不整合spring boot)</h2><h4 id="首先你要将mongodb镜像pull到本地"><a href="#首先你要将mongodb镜像pull到本地" class="headerlink" title="首先你要将mongodb镜像pull到本地"></a>首先你要将mongodb镜像pull到本地</h4><p>docker官方为我们提供了如何使用的guide</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure>



<p>pull到本地后运行镜像生成容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mongodb -d mongo</span><br></pre></td></tr></table></figure>

<p>给容器设置账号密码</p>
<p><code>-e</code>是环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mongodb -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo </span><br></pre></td></tr></table></figure>



<h4 id="持久化保存"><a href="#持久化保存" class="headerlink" title="持久化保存"></a>持久化保存</h4><p>docker也提供了数据的持久化保存</p>
<p>使用<code>-v</code> volume是docker提供的持久化保存工具，具体可以看<a href="https://docs.docker.com/storage/volumes/">Use volume</a>，这里提供一个例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mongodb -v docker-data/mongo:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=admin -d mongo </span><br></pre></td></tr></table></figure>



<p>这里我们又看到了 <code>:</code> 这个符号，其实它就是起到映射作用。</p>
<h4 id="使用mongodb"><a href="#使用mongodb" class="headerlink" title="使用mongodb"></a>使用mongodb</h4><h5 id="切换到bash命令行界面"><a href="#切换到bash命令行界面" class="headerlink" title="切换到bash命令行界面"></a>切换到bash命令行界面</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mongodb bash</span><br></pre></td></tr></table></figure>



<h5 id="在bash界面操作"><a href="#在bash界面操作" class="headerlink" title="在bash界面操作"></a>在bash界面操作</h5><p>这些命令下面连接到mongosh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongosh</span><br></pre></td></tr></table></figure>

<p>如果在创建容器的时候有指定账号密码，连接mongosh的时候还需要提供账号密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongosh -u admin -p admin</span><br></pre></td></tr></table></figure>





<h2 id="Spring-Boot连接mongodb"><a href="#Spring-Boot连接mongodb" class="headerlink" title="Spring Boot连接mongodb"></a>Spring Boot连接mongodb</h2><p><a href="https://www.mongodb.com/compatibility/docker">Mongodb</a>的官网下有这么一句话</p>
<blockquote>
<p>If you need to access the MongoDB server from another application running locally, you will need to expose a port using the <code>-p</code> argument.</p>
</blockquote>
<p>也就是说你需要通过<code>-p</code>这个flag&#x2F;option将你本地的端口Port映射到docker上的端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mongodb -d -p 27017:27017 mongo</span><br></pre></td></tr></table></figure>



<p>到了这里我们发现这个原理其实跟将Linux上的端口映射到Windows端口时一样的，通过端口映射，我们可以在本地操作Linux上的应用，比如使用<code>jupyter-notebook</code>时，先通过ssh连接到Linux，然后配置一下端口映射，就可以在Windows的浏览器使用<code>jupyter-notebook</code>了，尽管所有的包和依赖都安装Linux上，你还是可以通过端口映射在本地使用。</p>
<h2 id="额外知识"><a href="#额外知识" class="headerlink" title="额外知识"></a>额外知识</h2><p>相信学过操作系统的都有学过IPC，进程间通信分为两类，本地IPC，和远程IPC，</p>
<h3 id="Local-IPC"><a href="#Local-IPC" class="headerlink" title="Local IPC"></a>Local IPC</h3><ul>
<li>pipe</li>
<li>FIFO</li>
<li>share memory</li>
<li>signal</li>
</ul>
<h2 id="Remote-IPC"><a href="#Remote-IPC" class="headerlink" title="Remote IPC"></a>Remote IPC</h2><p>远程IPC是比较重要的，它是通过Socket来连接两台电脑，以此来实现IPC。</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>algo_bfs</title>
    <url>/2022/10/13/algo-bfs/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>algo_array</title>
    <url>/2022/10/13/algo-array/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>algo_doublepointer</title>
    <url>/2022/10/13/algo-doublepointer/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>algo_dfs</title>
    <url>/2022/10/13/algo-dfs/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>algo_dp</title>
    <url>/2022/10/13/algo-dp/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>algo_hashtable</title>
    <url>/2022/10/13/algo-hashtable/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>链表问题</title>
    <url>/2022/10/13/algo-linklist/</url>
    <content><![CDATA[<h1 id="链表-Linked-lissts"><a href="#链表-Linked-lissts" class="headerlink" title="链表(Linked lissts)"></a>链表(Linked lissts)</h1><blockquote>
<p>刷完题的第二天，在不看题解的情况下进行整理，总结</p>
</blockquote>
<h2 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h2><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h4><blockquote>
<p>双指针</p>
</blockquote>
<p>使用dummy结点指向剩余的链表。当或p1,p2其中一个为null时，直接将另外一个链表拼接到目标链表上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), p = dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> list1, p2 = list2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="literal">null</span> &amp;&amp; p2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val &gt; p2.val)&#123;</span><br><span class="line">                p.next = p2;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p.next = p1 ;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><h4 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h4><blockquote>
<p>思路：双指针</p>
</blockquote>
<h4 id="19-删除链表的导数第N个结点"><a href="#19-删除链表的导数第N个结点" class="headerlink" title="19. 删除链表的导数第N个结点"></a>19. 删除链表的导数第N个结点</h4><blockquote>
<p>思路：快慢指针</p>
</blockquote>
<h2 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a>Hard</h2>]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>algo_sort</title>
    <url>/2022/10/13/algo-sort/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Youtube上微服务视频的学习记录</title>
    <url>/2022/10/13/micro-service/</url>
    <content><![CDATA[<blockquote>
<p>软件过程是一门实践类学科，只看书的话会变得眼高手低，理论知识头头是道，但是一动手就露了馅。</p>
</blockquote>
<h4 id="Reference-Spring-Boot-Microservice"><a href="#Reference-Spring-Boot-Microservice" class="headerlink" title="Reference : Spring Boot Microservice"></a>Reference : <a href="https://www.youtube.com/watch?v=lh1oQHXVSc0&list=PLSVW22jAG8pBnhAdq9S8BpLnZ0_jVBj0c&ab_channel=ProgrammingTechie">Spring Boot Microservice</a></h4><p>Youtube上的这位博主个人感觉讲的很好，但是需要有一定的基础才能听懂，因为有一些基础知识</p>
<p>记录一下实践的思考和知识点。</p>
<h2 id="定义多个实体类"><a href="#定义多个实体类" class="headerlink" title="定义多个实体类"></a>定义多个实体类</h2><h4 id="The-relationship-between-entity"><a href="#The-relationship-between-entity" class="headerlink" title="The relationship between entity"></a>The relationship between entity</h4><p>定义多个实体类，我们需要考虑实体类间的关系是One-to-One，还是One-to-Many,还是Many-to-Many</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String orderNumber;</span><br><span class="line">    <span class="meta">@OneToMany(cascade = CascadeType.ALL)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderLineItems&gt; orderLineItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>实现我们的请求会经过Controller，然后到了Service，然后在Service层将请求转变为另一种类型的的对象，然后通过Repository保存到数据库中。</p>
<p>dispatcher分发请求到controller，然后controller将请求中的path variable或者parameter传入到service中(调用service的方法)，service调用repository的保存或查询的方法。</p>
<p>可以在spring boot application使用@bean注解在运行时加载数据</p>
<p><strong>在取数据的时候，如果session已经关闭了，就会有LazyInitializationException，而保持session的话，需要事务，在调用方法上加@Transactional</strong></p>
]]></content>
      <categories>
        <category>MicroServicer</category>
      </categories>
      <tags>
        <tag>MicroService</tag>
      </tags>
  </entry>
  <entry>
    <title>algo_string</title>
    <url>/2022/10/13/algo-string/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>本地机器连接Docker上的MySQL</title>
    <url>/2022/10/14/docker-mysql/</url>
    <content><![CDATA[<h3 id="pull-down-image"><a href="#pull-down-image" class="headerlink" title="pull down image"></a>pull down image</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>



<h3 id="Run-the-container"><a href="#Run-the-container" class="headerlink" title="Run the container"></a>Run the container</h3><h4 id="run-on-the-docker"><a href="#run-on-the-docker" class="headerlink" title="run on the docker"></a>run on the docker</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mysql -e MYSQL_ROOT_PASSWORD=111111 -d mysql</span><br></pre></td></tr></table></figure>



<h4 id="map-host-machine-port-to-docker-port-can-be-accessed-by-host-machine"><a href="#map-host-machine-port-to-docker-port-can-be-accessed-by-host-machine" class="headerlink" title="map host machine port to docker port(can be accessed by host machine)"></a>map host machine port to docker port(can be accessed by host machine)</h4><p>if you have already run the container with the same name without port map, you should stop the container and remove it.</p>
<h5 id="Stop-Running-Container"><a href="#Stop-Running-Container" class="headerlink" title="Stop Running Container"></a>Stop Running Container</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop mysql</span><br></pre></td></tr></table></figure>

<h5 id="Remove-container"><a href="#Remove-container" class="headerlink" title="Remove container"></a>Remove container</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> container-id</span><br></pre></td></tr></table></figure>



<h5 id="Map-port"><a href="#Map-port" class="headerlink" title="Map port"></a>Map port</h5><p>if you want to connect your application to mysql on docker, this is must thing to be done.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mysql -p 3307:3306 -e MYSQL_ROOT_PASSWORD=111111 -d mysql</span><br></pre></td></tr></table></figure>

<p>you can also map local machine’s port 3307 to docker’s port 3306</p>
<p>now MySQL server running on the docker, and MySQL client on host machine(like Windows) can connect to the server.</p>
<h4 id="Persitence-storage"><a href="#Persitence-storage" class="headerlink" title="Persitence storage"></a>Persitence storage</h4><p>It is used for sychronizing the data between local machine and docker container’s machine, data stored on docker you can’t not find it.</p>
<p>If you want to load docker data to host machine, you can use <code>-v</code> option to map data from docker to local machine.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name mysql -v /.../.../..:/.../.. -p 3307:3306  -e MYSQL_ROOT_PASSWORD=111111 -d mysql</span><br></pre></td></tr></table></figure>





<h4 id="Execute-it-in-the-interative-mode"><a href="#Execute-it-in-the-interative-mode" class="headerlink" title="Execute it in the interative mode"></a>Execute it in the interative mode</h4><p>if we don’t enter interative mode, each time we type command will have to start with <code>docker exec</code> and provide the password. In ther interative mode, it just like mysql is installed on the host machine </p>
<p>One thing you should know, <code>mysql</code> here is the name of container, not the image’s name,because we give this container password environment variable before, so we also need to use password to connect mysql.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql bash</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>and then enter the password “111111”,it will enter the mysql prompt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;:</span><br></pre></td></tr></table></figure>



<h2 id="Show-Logs"><a href="#Show-Logs" class="headerlink" title="Show Logs"></a>Show Logs</h2><p>you can also show the operation logs of the container.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs mysql</span><br></pre></td></tr></table></figure>

<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Let’s create mysql database on the docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database test1;</span><br></pre></td></tr></table></figure>

<p>it will show </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test1              |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>



<h4 id="Test-connection"><a href="#Test-connection" class="headerlink" title="Test connection"></a>Test connection</h4><p>change port 3306 to 3307 and enter default name “root” and password “111111”, click <code>Test Connection</code></p>
<p><img src="/docker-mysql.assets/test.png" alt="test"></p>
<h2 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h2><h4 id="Access-denied-for-user-‘root‘-’172-17-0-2’"><a href="#Access-denied-for-user-‘root‘-’172-17-0-2’" class="headerlink" title="Access denied for user ‘root‘@’172.17.0.2’"></a>Access denied for user ‘root‘@’172.17.0.2’</h4><h5 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;172.17.0.1&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>



<h5 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; flush privileges; </span><br></pre></td></tr></table></figure>



<p>finally, testing the connection</p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis and Mybatis-plus</title>
    <url>/2022/10/14/mybatis-mybatis-plus/</url>
    <content><![CDATA[<h1 id="记录一下Mybatis和Mybatis-plus的学习"><a href="#记录一下Mybatis和Mybatis-plus的学习" class="headerlink" title="记录一下Mybatis和Mybatis-plus的学习"></a>记录一下Mybatis和Mybatis-plus的学习</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Mybatis 是一个<strong>持久层框架</strong>，通过它我们可以简化日常开发时需要写的重复性代码，相比JDBC操作数据库，Mybatis 简化了操作，其他的一些持久层框架比如</p>
<ul>
<li>JPA</li>
<li>Hibernate</li>
</ul>
<p>每个基于 MyBatis 的应用都是以一个 <strong>SqlSessionFactory 的实例为核心</strong>的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p>
<p>Mybatis的原理是：通过SqlSessionFactory，可以创建SqlSession即会话。然后通过SqlSession来操作数据库的。</p>
<p>SqlSession本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认）。</p>
<p>Executor执行器要处理的SQL信息是封装到一个底层对象MappedStatement中。该对象包括：SQL语句、输入参数映射信息、输出结果集映射信息。其中输入参数和输出结果的映射类型包括java的简单类型、HashMap集合对象、POJO对象类型。</p>
<p><img src="/mybatis-mybatis-plus.assets/966901-20170116131307755-475253364.png" alt="966901-20170116131307755-475253364"></p>
<h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p>#{}：表示占位符，如果获取简单类型，#{}中可以使用value也可以使用其他名称；可以有效防止sql注入；设置参数时无需考虑参数类型，在使用时，它是预编译处理，MyBatis在处理#{ }时，它会将sql中的#{ }替换为？，然后调用PreparedStatement的set方法来赋值，传入字符串后，会在值两边加上单引号，如上面的值 “4,44,514”就会变成“ ‘4,44,514’ ”。</p>
<p>${}：表示sql拼接，如果获取简单类型，${}中只能使用value；无法防止sql注入；设置参数时必须考虑参数类型，主要用于获取配置文件数据,DAO接口中的参数信息。</p>
<h2 id="Name-Space"><a href="#Name-Space" class="headerlink" title="Name Space"></a>Name Space</h2><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="每个文件的作用"><a href="#每个文件的作用" class="headerlink" title="每个文件的作用"></a>每个文件的作用</h3><h4 id="SqlMapConfig-xml"><a href="#SqlMapConfig-xml" class="headerlink" title="SqlMapConfig.xml"></a>SqlMapConfig.xml</h4><p>这是一个全局配置文件，由两部分组成</p>
<ul>
<li>environments： 用于获取连接池连接，将来与spring整合时，这个就不要啦，由spring来配置数据库连接。</li>
<li>mappers：用于引用映射文件。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/user&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;User.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>environment在与spring boot整合时可以直接由<code>application.property</code>代替。</p>
<h4 id="映射文件：mapper-xml"><a href="#映射文件：mapper-xml" class="headerlink" title="映射文件：mapper.xml"></a>映射文件：mapper.xml</h4><p>映射文件就是框架的核心啦，下面这个文件就配置了java对象与数据库表之间的映射。</p>
<p>我们看到，其中4个标签：select，insert ，delete ，update 分别对应着“查，增，删，改”操作。每个标签中还有一些属性，下面来解释下：</p>
<p>id：给标签体内的sql操作起个名字，方便调用。<br>parameterType：传入参数的类型。传入java类型，转化为sql类型，添加到sql语句上。<br>resultType：返回结果类型。sql结果集转化为java类型并返回。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="XML方式"><a href="#XML方式" class="headerlink" title="XML方式"></a>XML方式</h5><p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:&#x2F;&#x2F; URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure>



<p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的<strong>数据源（DataSource）</strong>以及决定事务作用域和控制方式的<strong>事务管理器（TransactionManager）</strong>。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="Java方式"><a href="#Java方式" class="headerlink" title="Java方式"></a>Java方式</h5><p>如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置构建器，MyBatis 也提供了完整的配置类，提供了所有与 XML 文件等价的配置项。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line"><span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTransactionFactory</span>();</span><br><span class="line"><span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="string">&quot;development&quot;</span>, transactionFactory, dataSource);</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(environment);</span><br><span class="line">configuration.addMapper(BlogMapper.class);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(configuration);</span><br></pre></td></tr></table></figure>



<p>对应的XML配置文件，<code>TransactionFactory</code>和<code>DataSource</code> 放在<code>Environment</code>里面，然后<code>Environment</code>和<code>Mapper</code>放在Configuration里面。</p>
<img src="mybatis-mybatis-plus.assets/image-20221014225857069.png" alt="image-20221014225857069" style="zoom: 80%;" />



<h5 id="使用SqlSession"><a href="#使用SqlSession" class="headerlink" title="使用SqlSession"></a>使用SqlSession</h5><p>SqlSessionFactory 这个工厂创建完成后我们就可以使用SqlSession了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;SqlMapConfig.xml&quot;</span>;</span><br><span class="line">       <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">       <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">       <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">       <span class="comment">//---------------</span></span><br><span class="line">       <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.findUserById(<span class="number">2</span>);</span><br><span class="line">       System.out.println(user);</span><br><span class="line">       <span class="comment">//--------------</span></span><br><span class="line">       session.close();</span><br></pre></td></tr></table></figure>





<p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的方法需要强制转型，而且需要提供全限定类名，这会导致容易输错。下面的方法就是改版的，通过Java反射获取mapper。</p>
<p><strong>创建一个Mapper类，然后继承接口，通过接口来操作CRUD方法，因为是继承关系，Mapper会自动向上转型</strong></p>
<p>诚然，这种方式能够正常工作，对使用旧版本 MyBatis 的用户来说也比较熟悉。但现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><p>这个相对来说还是比较简单的，因为已经由前人帮我们封装好了接口，主要就是两个步骤，没有前后顺序要求。</p>
<p>通过代码生成器，我们可以自动生成，model和mapper</p>
<h4 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h4><p><img src="/mybatis-mybatis-plus.assets/image-20221014233546577.png" alt="image-20221014233546577"></p>
<h4 id="Step-1-XML-configuration"><a href="#Step-1-XML-configuration" class="headerlink" title="Step 1 XML configuration"></a>Step 1 XML configuration</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;testTables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/user&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">password</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 </span></span><br><span class="line"><span class="comment">            NUMERIC 类型解析为java.math.BigDecimal --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- targetProject:生成PO类的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.taotao.pojo&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject:mapper映射文件生成的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.taotao.mapper&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetPackage：mapper接口生成的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetPackage</span>=<span class="string">&quot;com.taotao.mapper&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定数据库表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">schema</span>=<span class="string">&quot;&quot;</span> <span class="attr">tableName</span>=<span class="string">&quot;tb_content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Step-2-Using-Java-configuration-file-to-generate-model-and-mapper"><a href="#Step-2-Using-Java-configuration-file-to-generate-model-and-mapper" class="headerlink" title="Step 2: Using Java configuration file to generate model and mapper"></a>Step 2: Using Java configuration file to generate model and mapper</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneratorSqlmap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generator</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; warnings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">overwrite</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//指定 逆向工程配置文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;generatorConfig.xml&quot;</span>); </span><br><span class="line">        <span class="type">ConfigurationParser</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationParser</span>(warnings);</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> cp.parseConfiguration(configFile);</span><br><span class="line">        <span class="type">DefaultShellCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShellCallback</span>(overwrite);</span><br><span class="line">        <span class="type">MyBatisGenerator</span> <span class="variable">myBatisGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBatisGenerator</span>(config,</span><br><span class="line">                callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">GeneratorSqlmap</span> <span class="variable">generatorSqlmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneratorSqlmap</span>();</span><br><span class="line">            generatorSqlmap.generator();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分页插件PageHelper"><a href="#分页插件PageHelper" class="headerlink" title="分页插件PageHelper"></a>分页插件PageHelper</h2><h4 id="Overview-2"><a href="#Overview-2" class="headerlink" title="Overview"></a>Overview</h4><p>PageHelper是国内非常优秀的一款开源的<a href="https://so.csdn.net/so/search?q=mybatis&spm=1001.2101.3001.7020">mybatis</a>分页插件，它支持基本主流与常用的数据库，例如mysql、oracle、mariaDB、DB2、SQLite、Hsqldb等。</p>
<p>新版拦截器是 <code>com.github.pagehelper.PageInterceptor</code>。 <code>com.github.pagehelper.PageHelper</code> 现在是一个特殊的 <code>dialect</code> 实现类，是分页插件的默认实现类，提供了和以前相同的用法。</p>
<p><img src="/mybatis-mybatis-plus.assets/20170611075934964.png" alt="20170611075934964"></p>
<p>PageHelper有两种配置方式。</p>
<h4 id="方式一：-MyBatis-配置-xml-中配置拦截器插件"><a href="#方式一：-MyBatis-配置-xml-中配置拦截器插件" class="headerlink" title="方式一：  MyBatis 配置 xml 中配置拦截器插件"></a>方式一：  MyBatis 配置 xml 中配置拦截器插件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:</span></span><br><span class="line"><span class="comment">    properties?, settings?,</span></span><br><span class="line"><span class="comment">    typeAliases?, typeHandlers?,</span></span><br><span class="line"><span class="comment">    objectFactory?,objectWrapperFactory?,</span></span><br><span class="line"><span class="comment">    plugins?,</span></span><br><span class="line"><span class="comment">    environments?, databaseIdProvider?, mappers?</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;param1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h4 id="方法二：-在-Spring-配置文件中配置拦截器插件"><a href="#方法二：-在-Spring-配置文件中配置拦截器插件" class="headerlink" title="方法二： 在 Spring 配置文件中配置拦截器插件"></a>方法二： 在 Spring 配置文件中配置拦截器插件</h4><p>在Spring的xml配置文件中，所有的东西都是一个bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注意其他配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--使用下面的方式配置参数，一行配置一个 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            params=value1</span><br><span class="line">          <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h1 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis-plus"></a>Mybatis-plus</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://juejin.cn/post/6961721367846715428#heading-9">https://juejin.cn/post/6961721367846715428#heading-9</a></p>
<h2 id="Overview-3"><a href="#Overview-3" class="headerlink" title="Overview"></a>Overview</h2><p>官网已经讲得很全面了，详细内容查看官网<a href="https://baomidou.com/pages/24112f/#%E7%89%B9%E6%80%A7">MP</a>,这里主要记录一下几个要点。</p>
<p><img src="https://baomidou.com/img/mybatis-plus-framework.jpg" alt="framework"></p>
<h2 id="8大注解"><a href="#8大注解" class="headerlink" title="8大注解"></a>8大注解</h2><ul>
<li><p><code>@TableName</code></p>
<p>注解在类上，指定类和数据库表的映射关系。<strong>实体类的类名（转成小写后）和数据库表名相同时</strong>，可以不指定该注解。</p>
</li>
</ul>
<ul>
<li>@TableId</li>
</ul>
<p>注解在实体类的某一字段上，<strong>表示这个字段对应数据库表的主键</strong>。当主键名为id时（表中列名为id，实体类中字段名为id），无需使用该注解显式指定主键，mp会自动关联。若类的字段名和表的列名不一致，可用<code>value</code>属性指定表的列名。另，这个注解有个重要的属性<code>type</code>，用于指定主键策略，参见<a href="#idType">主键策略小节</a></p>
<ul>
<li>@TableField</li>
</ul>
<p>注解在某一字段上，指定Java实体类的字段和数据库表的列的映射关系。</p>
<ul>
<li>@Version</li>
</ul>
<p>描述：乐观锁注解、标记 <code>@Verison</code> 在字段</p>
<ul>
<li>@EnumValue</li>
</ul>
<p>描述：普通枚举类注解(注解在枚举字段上</p>
<ul>
<li>@TableLogic</li>
</ul>
<p>描述：表字段逻辑处理注解逻辑删除</p>
<h2 id="乐观锁插件"><a href="#乐观锁插件" class="headerlink" title="乐观锁插件"></a>乐观锁插件</h2><p>当要更新一条记录的时候，希望这条记录没有被别人更新<br>乐观锁实现方式：</p>
<blockquote>
<ul>
<li>取出记录时，获取当前 version</li>
<li>更新时，带上这个 version</li>
<li>执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion</li>
<li>如果 version 不对，就更新失败</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Backend</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker_options</title>
    <url>/2022/10/15/docker-options/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>powershell_tips</title>
    <url>/2022/10/15/powershell-tips/</url>
    <content><![CDATA[<h4 id="在PowerShell使用Vim"><a href="#在PowerShell使用Vim" class="headerlink" title="在PowerShell使用Vim"></a>在PowerShell使用Vim</h4><p>首先到官网下载exe文件，安装的时候全部默认下一步</p>
<p>然后打开安装目录</p>
<p><code>C:\Program Files (x86)\Vim\vim90</code></p>
<p>打开环境变量设置，在Path中new一个</p>
<p>复制并粘贴到上面的安装目录到环境变量Path中</p>
<p>需要注意的是需要先关闭当前的PowerShell，然后重新打开PowerShell，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim</span><br></pre></td></tr></table></figure>



<p>如果出现下面的页面就是安装成功了</p>
<p><img src="/powershell-tips.assets/image-20221015104222733.png" alt="image-20221015104222733"></p>
<h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">New-Item</span> <span class="string">&quot;path/filename.extension&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Remove-Item</span> <span class="string">&quot;path/filename.extension&quot;</span></span><br></pre></td></tr></table></figure>





<h4 id="在命令行打开文件夹"><a href="#在命令行打开文件夹" class="headerlink" title="在命令行打开文件夹"></a>在命令行打开文件夹</h4><p>这个是打开当前目录还有子目录下的文件夹，如果需要打开其他目录需要使用绝对路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start folder-name</span><br></pre></td></tr></table></figure>



<h4 id="命令行打开markdown文件"><a href="#命令行打开markdown文件" class="headerlink" title="命令行打开markdown文件"></a>命令行打开markdown文件</h4><p>这个方法不止可以打开markdown文件，只需要改下extension就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.\file-namae.md</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.\file-name.extension</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>PowerShell</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ Learning record</title>
    <url>/2022/10/15/rabbitmq-tutorial/</url>
    <content><![CDATA[<h1 id="Rabbitmq-tutorial"><a href="#Rabbitmq-tutorial" class="headerlink" title="Rabbitmq tutorial"></a>Rabbitmq tutorial</h1><p>主要是对官方文档的整理</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>RabbitMQ is a <strong>message broker</strong>: it <strong>accepts and forwards messages</strong>. You can think about it as <strong>a post office</strong>: when you put the mail that you want posting in a post box, you can be sure that the letter carrier will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is <strong>a post box</strong>, a <strong>post office</strong>, and a <strong>letter carrier</strong>.</p>
<p>The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it **accepts, stores, and forwards **binary blobs of data ‒ <em>messages</em>.</p>
<p><img src="/rabbitmq-tutorial.assets/image-20221015101016525.png" alt="image-20221015101016525"></p>
<blockquote>
<p><em>Middleware</em> is a type of computer software that provides services to software applications beyond those available from the operating system. We can seed many middleware in software enginnering.</p>
</blockquote>
<h2 id="Terminalogy"><a href="#Terminalogy" class="headerlink" title="Terminalogy"></a>Terminalogy</h2><p><em><strong>Producing</strong></em> means nothing more than sending. A program that sends messages is a <em>producer</em> :</p>
<p><img src="/rabbitmq-tutorial.assets/image-20221015101150368.png" alt="image-20221015101150368"></p>
<p><em><strong>A queue</strong></em> is the name for a post box which lives inside RabbitMQ. Although messages flow through RabbitMQ and your applications, they can only be stored inside a <em>queue</em>. A <em>queue</em> is only bound by the host’s memory &amp; disk limits, it’s essentially a large message buffer. Many <em>producers</em> can send messages that go to one queue, and many <em>consumers</em> can try to receive data from one <em>queue</em>. This is how we represent a queue:</p>
<p><img src="/rabbitmq-tutorial.assets/image-20221015101215878.png" alt="image-20221015101215878"></p>
<p><em><strong>Consuming</strong></em> has a similar meaning to receiving. A <em>consumer</em> is a program that mostly waits to receive messages:</p>
<p><img src="/rabbitmq-tutorial.assets/image-20221015101233868.png" alt="image-20221015101233868"></p>
<p><strong>channel</strong></p>
<p>A Channel is <strong>the application session that is opened for each piece of your app to communicate with the RabbitMQ broker</strong>. </p>
<p>In other words, once we establish the connection between end to end, we commmunicate with the help of Channel.</p>
<p> “P” is our <strong>producer</strong> and “C” is our <strong>consumer</strong>. The box in the middle is a queue - a <strong>message buffer</strong> that RabbitMQ keeps on behalf of the consumer.</p>
<p><img src="/rabbitmq-tutorial.assets/image-20221015101336686.png" alt="image-20221015101336686"></p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>I am using Docker for learning RabbitMQ, it is very convinient, I recommend you try this way.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.10-management</span><br></pre></td></tr></table></figure>

<p>This command means run the RabbitMQ container in interative terminal(<code>-it</code>) mode which means you can directy use RabbitMQ command through docker, it also map local host <code>-p</code> port 5672 to docker’s 5672, it is used for connect RabbitMQ on docker, and another port 15672.</p>
<p><code>-rm</code> is used for removing container if exists.</p>
<h2 id="Hello-World-Example"><a href="#Hello-World-Example" class="headerlink" title="Hello World Example"></a>Hello World Example</h2><h4 id="Establish-connection-with-RabbitMQ-server"><a href="#Establish-connection-with-RabbitMQ-server" class="headerlink" title="Establish connection with RabbitMQ server"></a>Establish connection with RabbitMQ server</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br></pre></td></tr></table></figure>



<p>We’re connected now, to a broker on the local machine - hence the <em>localhost</em>. If we wanted to connect to a broker on a different machine we’d simply specify its <strong>name</strong> or <strong>IP address</strong> here.</p>
<p>If RabbitMQ on Linux, we can edit &#x2F;etc&#x2F;hosts file on Linux, configure the hostname and IP address mapping. for example</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/etc/hosts</span></span><br><span class="line"></span><br><span class="line">127.0.0.1  rabbitmq</span><br></pre></td></tr></table></figure>

<p>If you are fimilar with DNS,  Its is very simple.</p>
<h4 id="Check-recipient-queue-exists"><a href="#Check-recipient-queue-exists" class="headerlink" title="Check recipient queue exists"></a>Check recipient queue exists</h4><p>Next, before sending we need to make sure the recipient queue exists. If we send a message to non-existing location, RabbitMQ will just drop the message. Let’s create a <em>hello</em> queue to which the message will be delivered:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>At this point we’re ready to send a message. Our first message will just contain a string <em>Hello World!</em> and we want to send it to our <em>hello</em> queue.</p>
<p><strong>In RabbitMQ a message can never be sent directly to the queue, it always needs to go through an <em>exchange</em></strong></p>
<p>This exchange is special ‒ it allows us to specify exactly to which queue the message should go. The queue name needs to be specified in the routing_key parameter:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                      routing_key=<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">                      body=<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>Before exiting the program we need to make sure the <strong>network buffers</strong> were <strong>flushed</strong> and our message was actually delivered to RabbitMQ. We can do it by gently closing the connection.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">connection.close()</span><br></pre></td></tr></table></figure>



<h4 id="Receiving-message"><a href="#Receiving-message" class="headerlink" title="Receiving message"></a>Receiving message</h4><p>receive messages from the queue and print them on the screen</p>
<p>first we need to connect to RabbitMQ server. The code responsible for connecting to Rabbit is the same as previously	</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">&#x27;localhost&#x27;</span>))</span><br><span class="line">channel = connection.channel()</span><br></pre></td></tr></table></figure>



<p>The next step, just like before, is to make sure that the queue exists</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.queue_declare(queue=<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p><strong>You may ask why we declare the queue again ‒ we have already declared it in our previous code. We could avoid that if we were sure that the queue already exists. For example if send.py program was run before. But we’re not yet sure which program to run first. In such cases it’s a good practice to repeat declaring the queue in both programs</strong>.</p>
<p>Receiving messages from the queue is more complex. It works by subscribing a callback function to a queue. Whenever we receive a message, this callback function is called by the Pika library. In our case this function will print on the screen the contents of the message.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ch, method, properties, body</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [x] Received %r&quot;</span> % body)</span><br></pre></td></tr></table></figure>

<p>Next, we need to tell RabbitMQ that this particular callback function should receive messages from our <em>hello</em> queue:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel.basic_consume(queue=<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">                      auto_ack=<span class="literal">True</span>,</span><br><span class="line">                      on_message_callback=callback)</span><br></pre></td></tr></table></figure>



<h5 id="polling"><a href="#polling" class="headerlink" title="polling"></a>polling</h5><p>And finally, we enter a never-ending loop that waits for data and runs callbacks whenever necessary, and catch KeyboardInterrupt during program shutdown.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; [*] Waiting for messages. To exit press CTRL+C&#x27;</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Interrupted&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">except</span> SystemExit:</span><br><span class="line">            os._exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p>The main idea behind Work Queues (aka: <em>Task Queues</em>) is to avoid doing a resource-intensive task immediately and having to wait for it to complete. Instead we <strong>schedule</strong> the task to be done later. We <strong>encapsulate a <em>task</em> as a message</strong> and send it to the queue. A worker process running in the background will pop the tasks and eventually execute the job. When you run many workers the tasks will be shared between them.</p>
<h2 id="Publish-and-Subscribe"><a href="#Publish-and-Subscribe" class="headerlink" title="Publish and Subscribe"></a>Publish and Subscribe</h2><p>The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue. Actually, quite often the producer doesn’t even know if a message will be delivered to any queue at all.</p>
<p><img src="/rabbitmq-tutorial.assets/image-20221024154726879.png" alt="image-20221024154726879"></p>
<h4 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h4><p><strong>exchange</strong> like selector in Java NIO.  </p>
<p><strong>exchange</strong> types</p>
<ul>
<li>direct</li>
<li>topic </li>
<li>header </li>
<li>fanout</li>
</ul>
<h4 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h4><p>We use binding to bind the <strong>queue</strong> with <strong>exchange</strong>, with the help of binding, we can dispatch the message to different queue,</p>
<p>A binding is a relationship between an exchange and a queue. This can be simply read as: the queue is interested in messages from this exchange.</p>
<p><img src="/rabbitmq-tutorial.assets/image-20221024160229361.png" alt="image-20221024160229361"></p>
<p>Let’s see an example</p>
<p><img src="/rabbitmq-tutorial.assets/image-20221024160332119.png" alt="image-20221024160332119"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">channel.queue_bind(exchange=<span class="string">&#x27;logs&#x27;</span>,</span><br><span class="line">                   queue=result.method.queue)</span><br></pre></td></tr></table></figure>



<h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>A binding is a relationship between an exchange and a queue. This can be simply read as: the queue is interested in messages from this exchange.</p>
<h4 id="Direct-exchange"><a href="#Direct-exchange" class="headerlink" title="Direct exchange"></a>Direct exchange</h4><p>In the previous section, we use fanout exchange, this binding use broadcasting to all queues.</p>
<p>We can also use direct exchange. below is how direct exchange works.</p>
<p><img src="/rabbitmq-tutorial.assets/image-20221024160736145.png" alt="image-20221024160736145"></p>
<h5 id="Binding-key"><a href="#Binding-key" class="headerlink" title="Binding key"></a>Binding key</h5><p>with the help of direct exchange, we can directly dispatch message to the particular queue.</p>
<h4 id="Multiple-bindings"><a href="#Multiple-bindings" class="headerlink" title="Multiple bindings"></a>Multiple bindings</h4><p>It is perfectly legal to bind multiple queues with the same binding key. In our example we could add a binding between X and Q1 with binding key black. In that case, the direct exchange will behave like fanout and will broadcast the message to all the matching queues. A message with routing key black will be delivered to both Q1 and Q2</p>
<p><img src="/rabbitmq-tutorial.assets/image-20221024161129121.png" alt="image-20221024161129121"></p>
<h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2>]]></content>
      <categories>
        <category>MicroServicer</category>
        <category>Backend</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程(JUC)</title>
    <url>/2022/10/16/JUC/</url>
    <content><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="/JUC.assets/CgotOV3DgLSAGmEWAADo6Lxf6ww652.png" alt="CgotOV3DgLSAGmEWAADo6Lxf6ww652"></p>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><p>实际生产中常用的大多数并发工具类所对应的并发知识，包括线程池、synchronized、Lock 锁，悲观锁和乐观锁、可重入锁、公平锁和非公平锁、读写锁、ConcurrentHashMap、CopyOnWriteArrayList、ThreadLocal、6 种原子类、CAS 原理、线程协作的 CountDownLatch、CyclicBarrier、Semaphore、AQS 框架、Java 内存模型、happens-before 原则、volatile 关键字、线程创建和停止的正确方法、线程的 6 种状态、如何解决死锁等问题。</p>
<h2 id="实现线程的方法"><a href="#实现线程的方法" class="headerlink" title="实现线程的方法"></a>实现线程的方法</h2><blockquote>
<p>只有两种实现线程的方法，其它的都是对他们两个的封装，并提供一些额外的功能。</p>
</blockquote>
<p>两种创建线程的方式，而其他的创建方式，比如线程池或是定时器，它们仅仅是在 new Thread() 外做了一层封装，如果我们把这些都叫作一种新的方式，那么创建线程的方式便会千变万化、层出不穷，比如 JDK 更新了，它可能会多出几个类，会把 new Thread() 重新封装，表面上看又会是一种新的实现线程的方式，透过现象看本质，打开封装后，会<strong>发现它们最终都是基于 Runnable 接口或继承 Thread 类实现的</strong>。</p>
<h3 id="1-实现-Runnable-接口-Void"><a href="#1-实现-Runnable-接口-Void" class="headerlink" title="1. 实现 Runnable 接口(Void)"></a>1. 实现 Runnable 接口(Void)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&#x27;用实现Runnable接口实现线程&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第 1 种方式是通过实现 Runnable 接口实现多线程，如代码所示，首先通过 RunnableThread 类实现 Runnable 接口，然后重写 run() 方法，之后只需要把这个实现了 run() 方法的实例传到 Thread 类中就可以实现多线程。</p>
<h3 id="2-继承-Thread-类"><a href="#2-继承-Thread-类" class="headerlink" title="2. 继承 Thread 类"></a>2. 继承 Thread 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&#x27;用Thread类实现线程&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 2 种方式是继承 Thread 类，如代码所示，与第 1 种方式不同的是它没有实现接口，而是继承 Thread 类，并重写了其中的 run() 方法。相信上面这两种方式你一定非常熟悉，并且经常在工作中使用它们。</p>
<h3 id="3-线程池创建线程"><a href="#3-线程池创建线程" class="headerlink" title="3. 线程池创建线程"></a>3. 线程池创建线程</h3><p><strong>为什么需要线程池？</strong></p>
<p>没有线程池，我们需要反复的创建和删除线程，我们都知道线程在操作系统的switch context对资源的消耗很大，如果面对高并发的情况下，系统大部分资源都用来switch context，新建和创建，这是我们不能容忍的。</p>
<p>为什么说还有第 3 种或第 4 种方式呢？我们先来看看第 3 种方式：通过线程池创建线程。线程池确实实现了多线程，比如我们给线程池的线程数量设置成 10，那么就会有 10 个子线程来为我们工作，接下来，我们深入解析线程池中的源码，来看看线程池是怎么实现线程的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line"></span><br><span class="line">        group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line"></span><br><span class="line">            Thread.currentThread().getThreadGroup();</span><br><span class="line"></span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line"></span><br><span class="line">            poolNumber.getAndIncrement() +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line"></span><br><span class="line">                    namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line"></span><br><span class="line">            t.setDaemon(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line"></span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于线程池而言，本质上是通过线程工厂创建线程的，默认采用 DefaultThreadFactory ，它会给线程池创建的线程设置一些默认值，比如：线程的名字、是否是守护线程，以及线程的优先级等。但是**&#x3D;&#x3D;无论怎么设置这些属性，最终它还是通过 new Thread() 创建线程的&#x3D;&#x3D;** ，只不过这里的构造函数传入的参数要多一些，由此可以看出通过线程池创建线程并没有脱离最开始的那两种基本的创建方式，因为<strong>本质上还是通过 new Thread() 实现的</strong>。</p>
<h3 id="4-有返回值的-Callable-创建线程"><a href="#4-有返回值的-Callable-创建线程" class="headerlink" title="4. 有返回值的 Callable 创建线程()"></a>4. 有返回值的 Callable 创建线程()</h3><p>Callables are functional interfaces just like runnables but instead of being <code>void</code> they return a value.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CallableTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交任务，并用 Future提交返回结果</span></span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">CallableTask</span>());</span><br></pre></td></tr></table></figure>



<p>第 4 种线程创建方式是通过有返回值的 Callable 创建线程，Runnable 创建线程是无返回值的，而 Callable 和与之相关的 Future、FutureTask，它们可以把线程执行的结果作为返回值返回，如代码所示，实现了 Callable 接口，并且给它的泛型设置成 Integer，然后它会返回一个随机数。</p>
<p>但是，**&#x3D;&#x3D;无论是 Callable 还是 FutureTask，它们首先和 Runnable 一样，都是一个任务，是需要被执行的，而不是说它们本身就是线程&#x3D;&#x3D;<strong>。它们可以放到线程池中执行，如代码所示， submit() 方法把任务放到线程池中，并由线程池创建线程，不管用什么方法，</strong>最终都是靠线程来执行的，而子线程的创建方式仍脱离不了最开始讲的两种基本方式，也就是实现 Runnable 接口和继承 Thread 类**。</p>
<h3 id="5-其他创建方式"><a href="#5-其他创建方式" class="headerlink" title="5. 其他创建方式"></a>5. 其他创建方式</h3><h4 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲到这里你可能会说，我还知道一些其他的实现线程的方式。比如，定时器也可以实现线程，如果新建一个 Timer，令其每隔 10 秒或设置两个小时之后，执行一些任务，那么这时它确实也创建了线程并执行了任务，但如果我们深入分析定时器的源码会发现，<strong>本质上它还是会有一个继承自 Thread 类的 TimerThread</strong>，所以定时器创建线程最后又绕回到最开始说的两种方式。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *描述：匿名内部类创建线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或许你还会说，我还知道一些其他方式，比如匿名内部类或 lambda 表达式方式，实际上，匿名内部类或 lambda 表达式创建线程，它们仅仅是在语法层面上实现了线程，并不能把它归结于实现多线程的方式，如匿名内部类实现线程的代码所示，它仅仅是用一个匿名内部类把需要传入的 Runnable 给实例出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(Thread.currentThread().getName())).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看下 lambda 表达式方式。如代码所示，最终它们依然符合最开始所说的那两种实现线程的方式。</p>
<h3 id="实现-Runnable-接口究竟比继承-Thread-类实现线程好在哪里？"><a href="#实现-Runnable-接口究竟比继承-Thread-类实现线程好在哪里？" class="headerlink" title="实现 Runnable 接口究竟比继承 Thread 类实现线程好在哪里？"></a>实现 Runnable 接口究竟比继承 Thread 类实现线程好在哪里？</h3><p>虽然实现线程看似简单、基础，但实际上却暗藏玄机。首先，我们来看下为什么说本质上实现线程只有一种方式？</p>
<p>实现线程的方式到底有几种？大部分人会说有 2 种、3 种或是 4 种，很少有人会说有 1 种。我们接下来看看它们具体指什么？2 种实现方式的描述是最基本的，也是最为大家熟知的，我们就先来看看 2 种线程实现方式的源码。</p>
<h1 id="Thread-pool"><a href="#Thread-pool" class="headerlink" title="Thread pool"></a>Thread pool</h1><p>线程池就是创建一堆线程，然后放在那里，等着你去用它，避免了线程的反复创建和删除。</p>
<p>通常线程池会有一个size大小, 当然初始的线程创建是避免不了的。</p>
<p>当并发线程数超过线程池的size时，会将之后的线程放进一个queue中，为了避免线程一直在queue中，我们还会给处于queue中的线程设置。。。。</p>
<h1 id="Thread-Safe"><a href="#Thread-Safe" class="headerlink" title="Thread Safe"></a>Thread Safe</h1><p>Thread-safe code only manipulates shared data structures in a manner that ensures that all threads behave properly and fulfill their design specifications without unintended interaction. There are various strategies for making thread-safe data structures</p>
<p>线程安全是指对于共享数据的非原子性操作不会造成race condition，也就是说对critical section避免并发访问下的冲突。</p>
<p>用final keyword修饰的意味着不可变的，也就一定是thread safe的。</p>
<p>&#x3D;&#x3D;原子性也意味着不可以被 “中断”&#x3D;&#x3D;, 这里中断不一定是值执行被打断，也可以指执行期间有其它线程插入。</p>
<p>最常见的非原子操作就是，复合操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i++</span><br></pre></td></tr></table></figure>

<p>我们将i++在CPU中如何执行的进行分解：</p>
<ol>
<li>读取：CPU需要将 i 从磁盘读取到内存</li>
<li>执行：寄存器会对 i 执行加1操作</li>
<li>保持：将更新后的值保存到变量i</li>
</ol>
<p>我们可以看到只是三步执行，三步里面的任何一步都有可能有其他线程在执行，这就导致变量值还没保存就被其他线程读取，最终加1次数丢失。</p>
<p>但是我们日常生活中经常会对数据CRUD, 意味着数据会变动，所以为了保证系统的可靠性，在高并发环境下要保证线程安全。</p>
<p>通常是通过同步实现线程安全，Java中同步的实现方法有synchronized关键字和Lock接口。</p>
<p>A program may execute code in several threads simultaneously in a shared <a href="https://en.wikipedia.org/wiki/Address_space">address space</a> where each of those threads has access to virtually all of the <a href="https://en.wikipedia.org/wiki/Computer_storage">memory</a> of every other thread. Thread safety is a property that allows code to run in multithreaded environments by re-establishing some of the correspondences between the actual flow of control and the text of the program, by means of <a href="https://en.wikipedia.org/wiki/Synchronization_(computer_science)">synchronization</a></p>
<h1 id="Coroutines"><a href="#Coroutines" class="headerlink" title="Coroutines"></a>Coroutines</h1><h1 id="Executor-service"><a href="#Executor-service" class="headerlink" title="Executor service"></a>Executor service</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>有了executor，我们不需要手动创建thread，也就是不需要手动new Thread()。 </p>
<p>The Concurrency API introduces the concept of an <strong>ExecutorServic</strong> as a &#x3D;&#x3D;higher level replacement for working with threads directly&#x3D;&#x3D;</p>
<p><strong>Executors</strong> are capable of &#x3D;&#x3D;running asynchronous&#x3D;&#x3D; tasks and typically manage &#x3D;&#x3D;a pool of threads&#x3D;&#x3D;, so we don’t have to create new threads manually. All threads of the &#x3D;&#x3D;internal pool will be reused&#x3D;&#x3D;（不需要重复的创建和删除） under the hood for revenant tasks, so we can run as many concurrent tasks as we want throughout the life-cycle of our application with a single executor service.</p>
<h4 id="Submit"><a href="#Submit" class="headerlink" title="Submit()"></a>Submit()</h4><p>​	</p>
<p><code>submit()</code> doesn’t wait until the task completes, the executor service cannot return the result of the callable directly.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello &quot;</span> + threadName);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="shutdown-and-shutdownNow"><a href="#shutdown-and-shutdownNow" class="headerlink" title="shutdown() and shutdownNow()"></a>shutdown() and shutdownNow()</h4><p>如何关闭线程池, 我们有下面两种方法。</p>
<p>An <code>ExecutorService</code> provides two methods for that purpose: <code>shutdown()</code> waits for currently running tasks to finish while <code>shutdownNow()</code> interrupts all running tasks and shut the executor down immediately.</p>
<ul>
<li>shutdown(): wait util task finish and then stop.</li>
<li>shutdownNow(): stop immediately.</li>
</ul>
<h2 id="Scheduled-Executors"><a href="#Scheduled-Executors" class="headerlink" title="Scheduled Executors"></a>Scheduled Executors</h2><p>A <code>ScheduledExecutorService</code> is capable of scheduling tasks to run either periodically or once after a certain amount of time has elapsed.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Scheduling: &quot;</span> + System.nanoTime());</span><br><span class="line">ScheduledFuture&lt;?&gt; future = executor.schedule(task, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">remainingDelay</span> <span class="operator">=</span> future.getDelay(TimeUnit.MILLISECONDS);</span><br><span class="line">System.out.printf(<span class="string">&quot;Remaining Delay: %sms&quot;</span>, remainingDelay);</span><br></pre></td></tr></table></figure>



<h1 id="Synchronized-and-Lock"><a href="#Synchronized-and-Lock" class="headerlink" title="Synchronized and Lock"></a>Synchronized and Lock</h1><p>In java, we have &#x3D;&#x3D;two ways&#x3D;&#x3D; to implement synchronization</p>
<ol>
<li>synchronized keyword</li>
<li>Lock interface in the <em>Java</em>.util.concurrent.<em>locks</em> package</li>
</ol>
<p>原子性操作肯定不用上锁，但是对于非原子性操作，在面对并发情况下，多个线程对同一个资源有更改操作，我们把多线程对共享数据的修改这块代码叫做Critical Section，多线程相互竞争对共享资源的修改，就会面临Race Condiction。</p>
<p>如何解决这个问题，**&#x3D;&#x3D;上锁&#x3D;&#x3D;**</p>
<p>上锁也会面临死锁,饥饿这些错误，但是现在不考虑。</p>
<p>接下来两种常见的锁 Synchronized and Lock</p>
<p>Synchronized是隐式上锁，</p>
<p>Lock是显示上锁</p>
<p>形象地说，synchronized关键字是<strong>自动档</strong>，可以满足一切日常驾驶需求。但是如果你想要玩漂移或者各种骚操作，就需要<strong>手动档</strong>了——各种Lock的实现类。形象地说，synchronized关键字是<strong>自动档</strong>，可以满足一切日常驾驶需求。但是如果你想要玩漂移或者各种骚操作，就需要<strong>手动档</strong>了——各种Lock的实现类。</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>Use synchronized keyword to lock the cretical section</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incrementSync</span><span class="params">()</span> &#123;</span><br><span class="line">    count = count + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>java also support sychronized block</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">incrementSync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        count = count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p><img src="/JUC.assets/image-20221027104455742.png" alt="image-20221027104455742"></p>
<p>锁的类型并不一定是互斥的，只是它们的粒度不同，所以将他们分为不同锁，有一些锁甚至是包含关系</p>
<p><img src="/JUC.assets/image-20221027104836384.png" alt="image-20221027104836384"></p>
<p>也就是说有些锁是粗粒度锁，有一些是细粒度锁，粗粒度锁包含细粒度锁，是细粒度锁一定是粗粒度锁，反过来不成立。</p>
<p>就比如锁的一种宏观分类方式是<strong>悲观锁</strong>和<strong>乐观锁</strong>。悲观锁与乐观锁<strong>并不是特指某个锁</strong>（Java中没有哪个Lock实现类就叫PessimisticLock或OptimisticLock），而是在并发情况下的两种不同策略。</p>
<p>需要注意的是，不是所有的锁具有包含被包含关系，有一些所确实是互斥的</p>
<p><img src="/JUC.assets/image-20221027105151169.png" alt="image-20221027105151169"></p>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>The class <code>ReentrantLock</code> is a &#x3D;&#x3D;mutual exclusion lock&#x3D;&#x3D; with the same basic behavior as the implicit monitors accessed via the <code>synchronized</code> keyword but with extended capabilities. As the name suggests this lock implements reentrant characteristics just as implicit monitors.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><p>The interface <code>ReadWriteLock</code> specifies another type of lock maintaining a pair of locks for read and write access. The idea behind read-write locks is that it’s usually safe to read mutable variables concurrently as long as nobody is writing to this variable. So the read-lock can be held simultaneously by multiple threads as long as no threads hold the write-lock. This can improve performance and throughput in case that reads are more frequent than writes.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>The above example first acquires a write-lock in order to put a new value to the map after sleeping for one second. Before this task has finished two other tasks are being submitted trying to read the entry from the map and sleep for one second:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">readTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">executor.submit(readTask);</span><br><span class="line">executor.submit(readTask);</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br></pre></td></tr></table></figure>





<h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><h4 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h4><p><strong>binary semamhore</strong>: like mutual exclussion lock</p>
<p><strong>counting semaphore</strong>: allow a set of thread access.</p>
<p>允许一组线程获取锁，而不是只有一个</p>
<p>In addition to locks the Concurrency API also supports &#x3D;&#x3D;counting semaphores&#x3D;&#x3D;. Whereas locks usually grant exclusive access to variables or resources, a semaphore is capable of maintaining whole &#x3D;&#x3D;sets of permits&#x3D;&#x3D;. This is useful in different scenarios where you have to &#x3D;&#x3D;limit the amount concurrent access&#x3D;&#x3D; to certain parts of your application.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">longRunningTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">permit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        permit = semaphore.tryAcquire(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (permit) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Semaphore acquired&quot;</span>);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Could not acquire semaphore&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (permit) &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    .forEach(i -&gt; executor.submit(longRunningTask));</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br></pre></td></tr></table></figure>



<p>This is the ooutput of above program. we can find that only 5 thread are allowed access the resource.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore acquired</span><br><span class="line">Semaphore acquired</span><br><span class="line">Semaphore acquired</span><br><span class="line">Semaphore acquired</span><br><span class="line">Semaphore acquired</span><br><span class="line">Could not acquire semaphore</span><br><span class="line">Could not acquire semaphore</span><br><span class="line">Could not acquire semaphore</span><br><span class="line">Could not acquire semaphore</span><br><span class="line">Could not acquire semaphore</span><br></pre></td></tr></table></figure>



<p>信号量的一个最主要的作用就是，来控制那些需要限制并发访问量的资源。具体来讲，信号量会维护“许可证”的计数，而线程去访问共享资源前，必须先拿到许可证。线程可以从信号量中去“获取”一个许可证，一旦线程获取之后，信号量持有的许可证就转移过去了，所以信号量手中剩余的许可证要减一。</p>
<p>同理，线程也可以“释放”一个许可证，如果线程释放了许可证，这个许可证相当于被归还给信号量了，于是信号量中的许可证的可用数量加一。当信号量拥有的许可证数量减到 0 时，如果下个线程还想要获得许可证，那么这个线程就必须等待，直到之前得到许可证的线程释放，它才能获取。由于线程在没有获取到许可证之前不能进一步去访问被保护的共享资源，所以这就控制了资源的并发访问量，这就是整体思路</p>
<h2 id="Lock’s-condition"><a href="#Lock’s-condition" class="headerlink" title="Lock’s condition"></a>Lock’s condition</h2><p>Thread 1 enter wait state, thread 2 continue executing, after thread 2 finish, it will signal other threads and release lock. other threads acquire lock and enter runnable state.</p>
<p><img src="/JUC.assets/image-20221027134826748.png" alt="image-20221027134826748"></p>
<p>example</p>
<p><img src="/JUC.assets/image-20221027135049918.png" alt="image-20221027135049918"></p>
<p>Lock condition and synchronized comparation</p>
<p><img src="/JUC.assets/image-20221027134724768.png" alt="image-20221027134724768"></p>
<h4 id="Fairness"><a href="#Fairness" class="headerlink" title="Fairness"></a>Fairness</h4><p>signalAll(), both thread 0 and thread 1 will enter runnable state</p>
<p><img src="/JUC.assets/image-20221027135250807.png" alt="image-20221027135250807"></p>
<h4 id="Always-use-await-in-loop"><a href="#Always-use-await-in-loop" class="headerlink" title="Always use await in loop"></a>Always use await in loop</h4><p><img src="/JUC.assets/image-20221027135552850.png" alt="image-20221027135552850"></p>
<h3 id="Dead-Lock"><a href="#Dead-Lock" class="headerlink" title="Dead Lock"></a>Dead Lock</h3><p><img src="/JUC.assets/image-20221027151121665.png" alt="image-20221027151121665"></p>
<ol>
<li><strong>Mutual Exclusion:</strong> When two people meet in the landings, they can’t just walk through because there is space only for one person. This condition allows only one person (or process) to use the step between them (or the resource) is the first condition necessary for the occurrence of the deadlock.</li>
<li><strong>Hold and Wait:</strong> When the two people refuse to retreat and hold their ground, it is called holding. This is the next necessary condition for deadlock.</li>
</ol>
<p><img src="/JUC.assets/image-20221027151237065.png" alt="image-20221027151237065"></p>
<ol start="3">
<li><p><strong>No Preemption(非抢占):</strong> Preemption is temporarily interrupting an executing task and later resuming it(抢占式其它线程能够抢占当前资源).For resolving the deadlock one can simply cancel one of the processes for other to continue. But the Operating System doesn’t do so. It allocates the resources to the processors for as much time as is needed until the task is completed. Hence, there is no temporary reallocation of the resources. It is the third condition for deadlock. </p>
</li>
<li><p><strong>Circular Wait:</strong> When the two people refuse to retreat and wait for each other to retreat so that they can complete their task, it is called circular wait. It is the last condition for deadlock to occur.</p>
</li>
</ol>
<p><img src="/JUC.assets/image-20221027151212398.png" alt="image-20221027151212398"></p>
<h4 id="Deck-lock-avoidance-and-prevention"><a href="#Deck-lock-avoidance-and-prevention" class="headerlink" title="Deck lock avoidance and prevention"></a>Deck lock avoidance and prevention</h4><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Callables can be submitted to executor services just like runnables. But what about the callables result? Since <code>submit()</code> &#x3D;&#x3D;doesn’t wait until the task completes&#x3D;&#x3D;, the executor service cannot return the result of the callable directly. Instead the executor returns a special result of type <code>Future</code> which can be used to retrieve the actual result &#x3D;&#x3D;at a later point in time&#x3D;&#x3D;.</p>
<p>So we wrap the <strong>executor</strong> into <strong>future</strong>, so that we can retrieve the value of callable in the future.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;future done? &quot;</span> + future.isDone());</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;future done? &quot;</span> + future.isDone());</span><br><span class="line">System.out.print(<span class="string">&quot;result: &quot;</span> + result);</span><br></pre></td></tr></table></figure>



<h4 id="isDone"><a href="#isDone" class="headerlink" title="isDone()"></a>isDone()</h4><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>It is used for performing possiable &#x3D;&#x3D;asynchronous&#x3D;&#x3D; computation and triger depandant computation which could also be asynchronous </p>
<h1 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h1><blockquote>
<p>you can thinks it is like MapReduce framework in Bigdata</p>
</blockquote>
<p>最大效率利用可用的CPU cores.</p>
<p>Java 7 introduced the fork&#x2F;join framework. It provides tools to help speed up parallel processing by attempting to &#x3D;&#x3D;use all available processor cores&#x3D;&#x3D;. It accomplishes this <strong>through a divide and conquer approach.</strong></p>
<p>In practice, this means that <strong>the framework first “forks,”</strong> recursively breaking the task into smaller independent subtasks until they are simple enough to run asynchronously.</p>
<p>After that, <strong>the “join” part begins.</strong> The results of all subtasks are recursively joined into a single result. In the case of a task that returns void, the program simply waits until every subtask runs.</p>
<p>To provide effective parallel execution, the fork&#x2F;join framework uses a pool of threads called the <em>ForkJoinPool</em>. This pool manages worker threads of type <em>ForkJoinWorkerThread</em>.</p>
<h1 id="Atomic-variables-and-ConcurrentMap"><a href="#Atomic-variables-and-ConcurrentMap" class="headerlink" title="Atomic variables and ConcurrentMap"></a>Atomic variables and ConcurrentMap</h1><p>Atomic Variables and Concurrent Maps. Both have been greatly improved with the introduction of lambda expressions and functional programming</p>
<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>The package <code>java.concurrent.atomic</code> contains many useful classes to perform atomic operations. An operation is atomic when you can safely perform the operation in parallel on multiple threads &#x3D;&#x3D;without using the synchronized keyword or locks&#x3D;&#x3D;</p>
<p>the atomic classes make heavy use of <a href="http://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap</a> (CAS), &#x3D;&#x3D;an atomic instruction directly supported by most modern CPUs&#x3D;&#x3D;. Those instructions usually are much faster than synchronizing via locks. So my advice is to prefer atomic classes over locks in case you just have to change a single mutable variable concurrently.</p>
<p>通过CAS，直接在CPU里执行指令，所以速度非常快。</p>
<h4 id="incrementAndGet"><a href="#incrementAndGet" class="headerlink" title="incrementAndGet()"></a>incrementAndGet()</h4><p>给值加1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    .forEach(i -&gt; executor.submit(atomicInt::incrementAndGet));</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(atomicInt.get());    <span class="comment">// =&gt; 1000</span></span><br></pre></td></tr></table></figure>



<h4 id="updateAndGet"><a href="#updateAndGet" class="headerlink" title="updateAndGet()"></a>updateAndGet()</h4><p>有时候给值加1还是不够用的，我们需要其他操作，所以我们就需要updateAndGet()方法，本例中是给值加2.	</p>
<p>AtomicInteger supports various kinds of atomic operations. The method <code>updateAndGet()</code> accepts a lambda expression in order to perform arbitrary arithmetic operations upon the integer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">atomicInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    .forEach(i -&gt; &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt;</span><br><span class="line">            atomicInt.updateAndGet(n -&gt; n + <span class="number">2</span>);</span><br><span class="line">        executor.submit(task);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(atomicInt.get());    <span class="comment">// =&gt; 2000</span></span><br></pre></td></tr></table></figure>



<h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><p>加法器(Adder)和累加器(Accumulator)：<strong>原子类型的扩充与优化，主要有：LongAdder、LongAccumulator、DoubleAdder和DoubleAccumulator，比AtomicLong和AtomicDouble性能更优。</strong></p>
<p>在 JDK 8 中又新增了 LongAdder 这个类，这是一个针对 Long 类型的操作工具类。那么既然已经有了 AtomicLong，为何又要新增 LongAdder 这么一个类呢？</p>
<p>LongAdder是java8中新增的原子类，在多线程环境中，它比AtomicLong性能要高出不少，特别是写多的场景。</p>
<p>经过试验，LongAdder 的吞吐量大约是 AtomicLong 的十倍，不过凡事总要付出代价，LongAdder 在保证高效的同时，也需要消耗更多的空间。</p>
<p>The class <code>LongAdder</code> as an &#x3D;&#x3D;alternative to AtomicLong&#x3D;&#x3D; can be used to consecutively add values to a number.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">    .forEach(i -&gt; executor.submit(adder::increment));</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(adder.sumThenReset());   <span class="comment">// =&gt; 1000</span></span><br></pre></td></tr></table></figure>



<p>LongAdder provides methods <code>add()</code> and <code>increment()</code> just like the atomic number classes and is also thread-safe. But instead of summing up a single result this class maintains a set of variables internally to reduce contention over threads. The actual result can be retrieved by calling <code>sum()</code> or <code>sumThenReset()</code>.</p>
<h2 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h2><p>上面都是一些简单的操作，所以我们需要一些类来编写复杂操作</p>
<p>它用来写复杂的多项式。</p>
<p>LongAccumulator is a more generalized version of LongAdder. Instead of performing simple add operations the class <code>LongAccumulator</code> builds around a lambda expression of type <code>LongBinaryOperator</code> as demonstrated in this code sample:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LongBinaryOperator</span> <span class="variable">op</span> <span class="operator">=</span> (x, y) -&gt; <span class="number">2</span> * x + y;</span><br><span class="line"><span class="type">LongAccumulator</span> <span class="variable">accumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>(op, <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    .forEach(i -&gt; executor.submit(() -&gt; accumulator.accumulate(i)));</span><br><span class="line"></span><br><span class="line">stop(executor);</span><br><span class="line"></span><br><span class="line">System.out.println(accumulator.getThenReset());     <span class="comment">// =&gt; 2539</span></span><br></pre></td></tr></table></figure>



<h2 id="ConcurrentMap"><a href="#ConcurrentMap" class="headerlink" title="ConcurrentMap"></a>ConcurrentMap</h2><p>The interface <code>ConcurrentMap</code> extends the map interface and defines one of the most useful concurrent collection types. Java 8 introduces functional programming by adding new methods to this interface.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConcurrentMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;han&quot;</span>, <span class="string">&quot;solo&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;r2&quot;</span>, <span class="string">&quot;d2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;c3&quot;</span>, <span class="string">&quot;p0&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>All those methods above are part of the <code>ConcurrentMap</code> interface, thereby available to all implementations of that interface. In addition the most important implementation <code>ConcurrentHashMap</code> has been further enhanced with a couple of new methods to perform parallel operations upon the map.</p>
<p>Just like parallel streams those methods use a special <code>ForkJoinPool</code> available via <code>ForkJoinPool.commonPool()</code> in Java 8. This pool uses a preset parallelism which depends on the number of available cores. Four CPU cores are available on my machine which results in a parallelism of three</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ForkJoinPool.getCommonPoolParallelism());  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<h1 id="Phaser-and-CountDownLatch-and-CyclicBarrier"><a href="#Phaser-and-CountDownLatch-and-CyclicBarrier" class="headerlink" title="Phaser and CountDownLatch and CyclicBarrier"></a>Phaser and CountDownLatch and CyclicBarrier</h1><h2 id="Phaser-移相器"><a href="#Phaser-移相器" class="headerlink" title="Phaser(移相器)"></a>Phaser(移相器)</h2><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>我们先来介绍一下 CountDownLatch，它是 JDK 提供的<strong>并发流程控制</strong>的工具类，它是在 java.util.concurrent 包下，在 JDK1.5 以后加入的。下面举个例子来说明它主要在什么场景下使用。</p>
<p>比如我们去游乐园坐激流勇进，有的时候游乐园里人不是那么多，这时，管理员会让你稍等一下，等人坐满了再开船，这样的话可以在一定程度上节约游乐园的成本。座位有多少，就需要等多少人，这就是 <strong>CountDownLatch</strong> 的核心思想，等到一个设定的数值达到之后，才能出发。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier 和 CountDownLatch 确实有一定的相似性，它们都能阻塞一个或者一组线程，直到某种预定的条件达到之后，这些之前在等待的线程才会统一出发，继续向下执行。正因为它们有这个相似点，你可能会认为它们的作用是完全一样的，其实并不是。</p>
<p>CyclicBarrier 可以构造出一个集结点，当某一个线程执行 await() 的时候，它就会到这个集结点开始等待，等待这个栅栏被撤销。直到预定数量的线程都到了这个集结点之后，这个栅栏就会被撤销，之前等待的线程就在此刻统一出发，继续去执行剩下的任务。</p>
<p>举一个生活中的例子。假设我们班级春游去公园里玩，并且会租借三人自行车，每个人都可以骑，但由于这辆自行车是三人的，所以要凑齐三个人才能骑一辆，而且从公园大门走到自行车驿站需要一段时间。</p>
<h1 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h1><p><img src="/JUC.assets/image-20221027130423425.png" alt="image-20221027130423425"></p>
<p>如果你仔细观察，会发现这里有两次“Load a”和两次“Store a”，说明存在一定的重排序的优化空间。</p>
<p><img src="/JUC.assets/image-20221027130509845.png" alt="image-20221027130509845"></p>
<p>重排序后， a 的两次操作被放到一起，指令执行情况变为 Load a、Set to 100、Set to 110、 Store a。下面和 b 相关的指令不变，仍对应 Load b、 Set to 5、Store b。</p>
<p>可以看出，重排序后 a 的相关指令发生了变化，节省了一次 Load a 和一次 Store a。重排序通过减少执行指令，从而提高整体的运行速度，这就是重排序带来的优化和好处。</p>
<h2 id="重排序的-3-种情况"><a href="#重排序的-3-种情况" class="headerlink" title="重排序的 3 种情况"></a>重排序的 3 种情况</h2><p>1）编译器优化</p>
<p>编译器（包括 JVM、JIT 编译器等）出于优化的目的，例如当前有了数据 a，把对 a 的操作放到一起效率会更高，避免读取 b 后又返回来重新读取 a 的时间开销，此时在编译的过程中会进行一定程度的重排。不过重排序并不意味着可以任意排序，它需要需要保证重排序后，不改变单线程内的语义，否则如果能任意排序的话，程序早就逻辑混乱了。</p>
<p>（2）CPU 重排序</p>
<p>CPU 同样会有优化行为，这里的优化和编译器优化类似，都是通过乱序执行的技术来提高整体的执行效率。所以即使之前编译器不发生重排，CPU 也可能进行重排，我们在开发中，一定要考虑到重排序带来的后果。</p>
<p>（3） 内存的“重排序”</p>
<p>内存系统内不存在真正的重排序，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。由于内存有缓存的存在，在 JMM 里表现为主存和本地内存，而主存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。</p>
<p>举个例子，线程 1 修改了 a 的值，但是修改后没有来得及把新结果写回主存或者线程 2 没来得及读到最新的值，所以线程 2 看不到刚才线程 1 对 a 的修改，此时线程 2 看到的 a 还是等于初始值。但是线程 2 却可能看到线程 1 修改 a 之后的代码执行效果，表面上看起来像是发生了重顺序。</p>
<h1 id="Java的原子性"><a href="#Java的原子性" class="headerlink" title="Java的原子性"></a>Java的原子性</h1><p>在了解了原子操作的特性之后，让我们来看一下 Java 中有哪些操作是具备原子性的。Java 中的以下几种操作是具备原子性的，属于原子操作：</p>
<ul>
<li>&#x3D;&#x3D;除了 long 和 double 之外&#x3D;&#x3D;的基本类型（int、byte、boolean、short、char、float）的读&#x2F;写操作，都天然的具备原子性；</li>
<li>所有引用 <strong>reference</strong> 的读&#x2F;写操作；</li>
<li>加了 <strong>volatile</strong> 后，所有变量的读&#x2F;写操作（包含 long 和 double）。这也就意味着 long 和 double 加了 volatile 关键字之后，对它们的读写操作同样具备原子性；</li>
<li>在 java.concurrent.Atomic 包中的一部分类的一部分方法是具备原子性的，比如 AtomicInteger 的 incrementAndGet 方法。</li>
</ul>
<p><strong>Non-Atomic Treatment of double and long</strong></p>
<p>For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.</p>
<p>Writes and reads of volatile long and double values are always atomic.</p>
<p>Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.</p>
<p>Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.</p>
<p>Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.</p>
<p>从刚才的 JVM 规范中我们可以知道，long 和 double 的值需要占用 64 位的内存空间，而对于 64 位值的写入，可以分为两个 32 位的操作来进行。</p>
<p>这样一来，本来是一个整体的赋值操作，就可能被拆分为低 32 位和高 32 位的两个操作。如果在这两个操作之间发生了其他线程对这个值的读操作，就可能会读到一个错误、不完整的值。</p>
<p>JVM 的开发者可以自由选择是否把 64 位的 long 和 double 的读写操作作为原子操作去实现，并且规范推荐 JVM 将其实现为原子操作。当然，JVM 的开发者也有权利不这么做，这同样是符合规范的。</p>
<p>规范同样规定，如果使用 volatile 修饰了 long 和 double，那么其读写操作就必须具备原子性了。同时，规范鼓励程序员使用 volatile 关键字对这个问题加以控制，由于规范规定了对于 volatile long 和 volatile double 而言，JVM 必须保证其读写操作的原子性，所以加了 volatile 之后，对于程序员而言，就可以确保程序正确。</p>
<p><strong>实际开发中</strong></p>
<p>在开发过程中没有给 long 和 double 加 volatile，好像也没有出现过问题？而且，在以后的开发过程中，是不是必须给 long 和 double 加 volatile 才是安全的？</p>
<p>其实在实际开发中，读取到“半个变量”的情况非常罕见，这个情况在目前主流的 Java 虚拟机中不会出现。因为 JVM 规范虽然不强制虚拟机把 long 和 double 的变量写操作实现为原子操作，但它其实是“强烈建议”虚拟机去把该操作作为原子操作来实现的。</p>
<p><strong>原子操作</strong> <strong>+</strong> <strong>原子操作</strong> <strong>!&#x3D;</strong> <strong>原子操作</strong></p>
<h1 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h1><p>In the multiple core computer system, we will have a shared area called “shared cache”, each core will only execute one thread at a time and each core have local cache.</p>
<p><img src="/JUC.assets/image-20221027131719442.png" alt="image-20221027131719442"></p>
<p>&#x3D;&#x3D;volatile只保证了可见性，不能保证原子性&#x3D;&#x3D;，要保证原子性我们需要借助其他同步(Synchronization)方法。</p>
<p>除了 volatile 关键字可以让变量保证可见性外，synchronized、Lock、并发集合等一系列工具都可以在一定程度上保证可见性，具体保证可见性的时机和手段</p>
<h1 id="Double-Checked-Locking-with-singleton"><a href="#Double-Checked-Locking-with-singleton" class="headerlink" title="Double Checked Locking with singleton"></a>Double Checked Locking with singleton</h1><p>double-checked locking <strong>design pattern</strong>, This pattern reduces the number of lock acquisitions by simply checking the locking condition beforehand</p>
<h2 id="Early-initialization"><a href="#Early-initialization" class="headerlink" title="Early initialization"></a>Early initialization</h2><h2 id="Lazy-Initializaiton-on-demand"><a href="#Lazy-Initializaiton-on-demand" class="headerlink" title="Lazy Initializaiton(on demand)"></a>Lazy Initializaiton(on demand)</h2><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>compare and swap</p>
<p>它是一种思想、一种算法。</p>
<p>在多线程的情况下，各个代码的执行顺序是不能确定的，所以为了保证并发安全，我们可以使用互斥锁。而 CAS 的特点是避免使用互斥锁，当多个线程同时使用 CAS 更新同一个变量时，只有其中一个线程能够操作成功，而其他线程都会更新失败。不过和同步互斥锁不同的是，更新失败的线程并<strong>不会被阻塞</strong>，而是被告知这次由于竞争而导致的操作失败，但还可以再次尝试。</p>
<p>CAS 被广泛应用在并发编程领域中，以实现那些不会被打断的数据交换操作，从而就&#x3D;&#x3D;实现了无锁的线程安全&#x3D;&#x3D;。</p>
<p>在大多数&#x3D;&#x3D;处理器的指令&#x3D;&#x3D;中，都会实现 &#x3D;&#x3D;CAS 相关的指令&#x3D;&#x3D;，这一条指令就可以完成“<strong>比较并交换</strong>”的操作，也正是由于&#x3D;&#x3D;这是一条（而不是多条）CPU 指令&#x3D;&#x3D;，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以&#x3D;&#x3D;无需我们程序员来操心&#x3D;&#x3D;。</p>
<p>JDK 正是利用了这些 CAS 指令，可以实现并发的数据结构，比如 AtomicInteger 等原子类。</p>
<p>模拟CAS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 描述：     模拟CAS操作，等价代码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimulatedCAS</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">compareAndSwap</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue == expectedValue) &#123;</span><br><span class="line"></span><br><span class="line">            value = newValue;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>compareAndSwap 方法是被 <strong>synchronized</strong> 修饰的，我们用同步方法为 CAS 的等价代码保证了原子性。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/2022/10/15/Java-NIO/</url>
    <content><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><p><a href="https://www.infoq.cn/news/netty-server-create?utm_source=related_read_bottom&amp;utm_medium=article">https://www.infoq.cn/news/netty-server-create?utm_source=related_read_bottom&amp;utm_medium=article</a></p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="/Java-NIO.assets/image-20221015162825247.png" alt="image-20221015162825247"></p>
<p>在JDK1.4以上的版本才提供NIO，那在之前使用的是什么呢？答案很简单，就是<strong>BIO</strong>(阻塞式IO)，也就是我们常用的IO流。</p>
<p>BIO的问题其实不用多说了，因为在使用BIO时，主线程会进入阻塞状态，这就非常影响程序的性能，<strong>不能充分利用机器资源</strong>。但是这样就会有人提出疑问了，那我<strong>使用多线程</strong>不就可以了吗？</p>
<p>但是在高并发的情况下，会创建很多线程，线程会占用内存，线程之间的切换也会浪费资源开销。</p>
<p>而NIO<strong>只有在连接&#x2F;通道真正有读写事件</strong>发生	时(<strong>事件驱动</strong>)，<strong>才会进行读写</strong>，就大大地减少了系统的开销。不必为每一个连接都创建一个线程，也不必去维护多个线程。</p>
<p><strong>避免了多个线程之间的上下文切换</strong>，导致资源的浪费。</p>
<p>As shown in the picture it only has one thread and the whole process is carried out using a concept called <strong>“Event Loop”</strong></p>
<p><img src="/Java-NIO.assets/image-20221010141518412.png" alt="image-20221010141518412"></p>
<h2 id="Core-components"><a href="#Core-components" class="headerlink" title="Core components"></a>Core components</h2><ol>
<li>Channels: which are containers for data,charsets and their associated decoders and encoders,which translate between bytes and Unicode characters.</li>
<li>Buffer: various types,which represent connections to entities capable of performing I&#x2F;O operations</li>
<li>Selector: Selectors and selection keys, which together with selectable channels define a multiplexed, non-blocking I&#x2F;O facility.</li>
</ol>
<p><img src="/Java-NIO.assets/image-20221010141340717.png" alt="image-20221010141340717"></p>
<p>Java NIO has more classes and components than these, but the <code>Channel</code>, <code>Buffer</code> and <code>Selector</code> forms the core of the API, in my opinion. The rest of the components, like <code>Pipe</code> and <code>FileLock</code> are merely utility classes to be used in conjunction with the three core components.</p>
<h3 id="Buffer-and-Channel"><a href="#Buffer-and-Channel" class="headerlink" title="Buffer and Channel"></a>Buffer and Channel</h3><p>The relationship between <em><strong>Channel</strong></em> and <strong>Buffer</strong> is similar to the relationship between a bowl and a spoon. The spoon can be used as a small container to take the sugar from the bowl and it can also be used as a small container to put the sugar from the outside into the bowl. Thus, the spoon acts as a <strong>Buffer</strong> and the bowl acts as a <em><strong>Channel</strong></em>.</p>
<p><img src="/Java-NIO.assets/image-20221015163514075.png" alt="image-20221015163514075"></p>
<p><img src="/Java-NIO.assets/image-20221015163543544.png" alt="image-20221015163543544"></p>
<p><strong>Capacity, limit, position</strong> and <strong>mark</strong> are the 4 most important terms of <strong>Java NIO Buffer</strong>, they will be explained in detail below. In both read and write modes, the cursor always moves to the right.</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><em><strong>Channel</strong></em> is an interface in the <strong>java.nio.channels</strong> package - an important component in <strong>Java New IO (Java NIO)</strong>. As we know <strong>Java NIO</strong> was first introduced from <strong>Java 1.4</strong> as an alternative to traditional <strong>Java IO</strong> for the purpose of improving program performance.</p>
<p><img src="/Java-NIO.assets/image-20221015164354688.png" alt="image-20221015164354688"></p>
<p><em><strong>Channel</strong></em> represents an open connection to an entity, such as a hardware device, <strong>file, socket</strong>, or program components, that is capable of performing <strong>IO (Input&#x2F;Output)</strong> operations. In general, to read or write data to an <strong>IO</strong> device with <strong>Java NIO,</strong> you must open a <em><strong>Channel</strong></em>.</p>
<p>all IO in NIO starts with a <code>Channel</code>. A <code>Channel</code> is a bit like a stream. From the <code>Channel</code> data can be read into a <code>Buffer</code>. Data can also be written from a <code>Buffer</code> into a <code>Channel</code>. Here is an illustration of that:</p>
<p><img src="/Java-NIO.assets/image-20221010135837729.png" alt="image-20221010135837729"></p>
<p>There are several <code>Channel</code> and <code>Buffer</code> types. Here is a list of the primary <code>Channel</code> implementations in Java NIO:</p>
<p>As you can see, these channels cover UDP + TCP network IO, and file IO.</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<blockquote>
<p><strong>Channel本身并不存储数据，只是负责数据的运输</strong>。必须要和<code>Buffer</code>一起使用。</p>
</blockquote>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p><a href="https://o7planning.org/13901/java-buffer">https://o7planning.org/13901/java-buffer</a></p>
<p><img src="/Java-NIO.assets/image-20221015163237061.png" alt="image-20221015163237061"></p>
<p><code>Buffer</code>是一个内存块。在<code>NIO</code>中，所有的数据都是用<code>Buffer</code>处理，有读写两种模式。所以NIO和传统的IO的区别就体现在这里。传统IO是面向<code>Stream</code>流，<code>NIO</code>而是面向缓冲区(<code>Buffer</code>)。</p>
<p>Here is a list of the core <code>Buffer</code> implementations in Java NIO:</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>These <code>Buffer</code>‘s cover the basic data types that you can send via IO: byte, short, int, long, float, double and characters.</p>
<p>Java NIO also has a <code>MappedByteBuffer</code> which is used in conjunction with memory mapped files. I’ll leave this <code>Buffer</code> out of this overview though.</p>
<h3 id="Create-Buffer"><a href="#Create-Buffer" class="headerlink" title="Create Buffer"></a>Create Buffer</h3><p>主要分成两种：JVM堆内内存块Buffer、堆外内存块Buffer。</p>
<p>创建堆内内存块(非直接缓冲区)的方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建堆内内存块HeapByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;java技术爱好者&quot;</span>;</span><br><span class="line"><span class="comment">//包装一个byte[]数组获得一个Buffer，实际类型是HeapByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer2</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br></pre></td></tr></table></figure>

<p>创建堆外内存块(直接缓冲区)的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建堆外内存块DirectByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer3</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h2><p><code>Selector</code>翻译成<strong>选择器</strong>，有些人也会翻译成<strong>多路复用器</strong>，实际上指的是同一样东西。</p>
<p>只有网络IO才会使用选择器，文件IO是不需要使用的。</p>
<p>选择器可以说是NIO的核心组件，它可以监听通道的状态，来实现异步非阻塞的IO。换句话说，也就是事件驱动。以此实现<strong>单线程管理多个Channel</strong>的目的。</p>
<p>A <code>Selector</code> allows a <strong>single thread</strong> to handle multiple <code>Channel</code>‘s. This is handy if your application has many connections (Channels) open, but only has low traffic on each connection. For instance, in a chat server.</p>
<p>Here is an illustration of a thread using a <code>Selector</code> to handle 3 <code>Channel</code>‘s:</p>
<p><img src="/Java-NIO.assets/image-20221010140125528.png" alt="image-20221010140125528"></p>
<p>To use a <code>Selector</code> you &#x3D;&#x3D;register the <code>Channel</code>‘s with&#x3D;&#x3D; it. Then you call it’s <code>select()</code> method. This method will block until there is an event ready for one of the registered channels. Once the method returns, the thread can then process these events. Examples of events are incoming connection, data received etc.</p>
<h3 id="Selection-key"><a href="#Selection-key" class="headerlink" title="Selection key"></a>Selection key</h3><ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ol>
<p>A channel that “fires an event” is also said to be “ready” for that event. So, a channel that has connected successfully to another server is “connect ready”. A server socket channel which accepts an incoming connection is “accept” ready. A channel that has data ready to be read is “read” ready. A channel that is ready for you to write data to it, is “write” ready.</p>
<p>These &#x3D;&#x3D;four events are&#x3D;&#x3D; represented by the four <code>SelectionKey</code> constants:</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>If you are interested in more than one event, OR the constants together, like this:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;   </span><br></pre></td></tr></table></figure>

<h2 id="Scatter-x2F-Gather"><a href="#Scatter-x2F-Gather" class="headerlink" title="Scatter &#x2F; Gather"></a>Scatter &#x2F; Gather</h2><p>A &#x3D;&#x3D;<strong>scattering read</strong>&#x3D;&#x3D; from a channel is a read operation that reads data into more than one buffer. Thus, the channel “scatters” the data from the channel into multiple buffers.</p>
<p>A &#x3D;&#x3D;<strong>gathering write</strong>&#x3D;&#x3D; to a channel is a write operation that writes data from more than one buffer into a single channel. Thus, the channel “gathers” the data from multiple buffers into one channel.</p>
<p>Scatter &#x2F; gather can be really useful in situations where you need to work with various parts of the transmitted data separately. For instance, if a message consists of a header and a body, you might keep the header and body in separate buffers. Doing so may make it easier for you to work with header and body separately.</p>
<p><img src="/Java-NIO.assets/image-20221010140507397.png" alt="image-20221010140507397"></p>
<p><img src="/Java-NIO.assets/image-20221010140521240.png" alt="image-20221010140521240"></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch学习记录</title>
    <url>/2022/10/18/elsatic-search/</url>
    <content><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><blockquote>
<p> Once you start the elastic search, cluster will automatically created.</p>
</blockquote>
<p>ElasticSearch is used for storing and analyzing data ingested by <code>Beats</code> and <code>Logstash</code> and we can use <code>Kibana</code> to visualize the data.</p>
<p><img src="/elsatic-search.assets/es-introduce-1-1.png" alt="es-introduce-1-1"></p>
<p>compare with RDBMS</p>
<table>
<thead>
<tr>
<th><strong>MySQL</strong></th>
<th><strong>Elasticsearch</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Table</td>
<td>Index</td>
<td>索引(index)，就是文档的集合，类似数据库的表(table)</td>
</tr>
<tr>
<td>Row</td>
<td>Document</td>
<td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td>
</tr>
<tr>
<td>Column</td>
<td>Field</td>
<td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td>
</tr>
<tr>
<td>Schema</td>
<td>Mapping</td>
<td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>
</tr>
<tr>
<td>SQL</td>
<td>DSL</td>
<td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td>
</tr>
</tbody></table>
<p>When we run ElasticSearch, we start a cluster, this cluster have at least one node</p>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><blockquote>
<p>Keep track of Document</p>
</blockquote>
<p>Index is virtually</p>
<p><img src="/elsatic-search.assets/image-20221018090755219.png" alt="image-20221018090755219"></p>
<h2 id="Sharding"><a href="#Sharding" class="headerlink" title="Sharding"></a>Sharding</h2><blockquote>
<p>Shard is where document are stored</p>
</blockquote>
<p>Index is not actually storing document, it just <strong>a virtual thing that keep track of where documents are stored</strong> .</p>
<p>each document on the different Node in the same Index is so called <code>Shard</code> .shard is where data is stored which we wanna search.</p>
<p>sharding is multiple shards storing across nodes for the same index</p>
<p><img src="/elsatic-search.assets/image-20221018090646736.png" alt="image-20221018090646736"></p>
<h3 id="Why-we-need-Sharding"><a href="#Why-we-need-Sharding" class="headerlink" title="Why we need Sharding"></a>Why we need Sharding</h3><p>because shard have limited capacity, in order to store large size data, we need multiple shards to store document</p>
<p>Sharding can also speed up our search</p>
<p><img src="/elsatic-search.assets/image-20221018092113454.png" alt="image-20221018092113454"></p>
<p>with the help of concurrent and sharding, search will be parallel.</p>
<p><img src="/elsatic-search.assets/image-20221018092154041.png" alt="image-20221018092154041"></p>
<h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><p>sometime, data will be lost, if we haven’t replication of that data, we will lose it forever, we should avoid this, this is why we need replication.  High avalible </p>
<p><img src="/elsatic-search.assets/image-20221018092617781.png" alt="image-20221018092617781"></p>
<h2 id="Basic-commands"><a href="#Basic-commands" class="headerlink" title="Basic commands"></a>Basic commands</h2><p>document in elasticsearch are grouped in index, so let’s create an index</p>
<h4 id="Create-an-index"><a href="#Create-an-index" class="headerlink" title="Create an index"></a>Create an index</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT index_name</span><br><span class="line"></span><br><span class="line">PUT <span class="built_in">test</span></span><br></pre></td></tr></table></figure>



<h4 id="Create-document-inside-index-with-filed-Index-a-document"><a href="#Create-document-inside-index-with-filed-Index-a-document" class="headerlink" title="Create document inside index with filed(Index a document)"></a>Create document inside index with filed(Index a document)</h4><p>When indexing a document, both HTTP verbs POST or PUT can be used.</p>
<p>Use POST when you want Elasticsearch to <strong>autogenerate an id</strong> for your document</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST index_name/document_name</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;filed_name&quot;</span>: <span class="string">&quot;filed_value&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST <span class="built_in">test</span>/_doc</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;favoraite&quot;</span>: <span class="string">&quot;money&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Use PUT when you want to <strong>assign a specific id</strong> to your document</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT index_name/document_name/document_id</span><br><span class="line"></span><br><span class="line">PUT <span class="built_in">test</span>/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;favoraite&quot;</span>: <span class="string">&quot;more money&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Using those commands will override the document, if you don’t want document be overwritten,you can use <code>_create</code> endpoint.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT index_name/document_id</span><br><span class="line"></span><br><span class="line">POST <span class="built_in">test</span>/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;favoraite&quot;</span>: <span class="string">&quot;more money&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If document 1 already exits, it will throw 404 error, you can’t overwrite it</p>
<h4 id="Read-from-document"><a href="#Read-from-document" class="headerlink" title="Read from document"></a>Read from document</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET index_name/document_name/document_id</span><br><span class="line"></span><br><span class="line">GET <span class="built_in">test</span>/_doc/1</span><br></pre></td></tr></table></figure>



<h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST index_name/_update/document_id</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;document_name&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;filed_name1&quot;</span>: <span class="string">&quot;filed_value&quot;</span>,</span><br><span class="line">    <span class="string">&quot;filed_name2&quot;</span>: <span class="string">&quot;filed_value&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST index_name/_update/document_id</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;test&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;field1&quot;</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">    <span class="string">&quot;field2&quot;</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE index_name/document_name/document_id</span><br></pre></td></tr></table></figure>



<h4 id="Get-info-about-cluster-health"><a href="#Get-info-about-cluster-health" class="headerlink" title="Get info about cluster health"></a>Get info about cluster health</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET _API/parameter</span><br><span class="line"></span><br><span class="line">GET _cluster/health</span><br></pre></td></tr></table></figure>



<h4 id="Get-info-about-nodes-in-a-cluster"><a href="#Get-info-about-nodes-in-a-cluster" class="headerlink" title="Get info about nodes in a cluster"></a>Get info about nodes in a cluster</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET _node/stats</span><br></pre></td></tr></table></figure>





<h2 id="Query-and-Aggression"><a href="#Query-and-Aggression" class="headerlink" title="Query and Aggression"></a>Query and Aggression</h2><h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><h4 id="Search-for-data-within-a-specific-time-range"><a href="#Search-for-data-within-a-specific-time-range" class="headerlink" title="Search for data within a specific time range"></a>Search for data within a specific time range</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET enter_name_of_the_index_here/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Specify the type of query here&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Enter name of the field here&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;gte&quot;</span>: <span class="string">&quot;Enter lowest value of the range here&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lte&quot;</span>: <span class="string">&quot;Enter highest value of the range here&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET news_headlines/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;date&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;gte&quot;</span>: <span class="string">&quot;2015-06-20&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lte&quot;</span>: <span class="string">&quot;2015-09-22&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><h4 id="Analyze-the-data-to-show-the-categories-of-news-headlines-in-our-dataset"><a href="#Analyze-the-data-to-show-the-categories-of-news-headlines-in-our-dataset" class="headerlink" title="Analyze the data to show the categories of news headlines in our dataset"></a>Analyze the data to show the categories of news headlines in our dataset</h4><p>An aggregation summarizes your data as metrics, statistics, and other analytics.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET enter_name_of_the_index_here/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name your aggregation here&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;specify aggregation type here&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;name the field you want to aggregate here&quot;</span>,</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: state how many buckets you want returned here</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET news_headlines/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;by_category&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;category&quot;</span>,</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: 100</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Metric-Aggregations"><a href="#Metric-Aggregations" class="headerlink" title="Metric Aggregations"></a>Metric Aggregations</h4><p>Metric aggregations are used to compute numeric values based on your dataset. It can be used to calculate the values of sum,min, max, avg, unique count(cardinality) and etc.</p>
<p>sum aggregation</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET Enter_name_of_the_index_here/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Name your aggregations here&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;sum&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;Name the field you want to aggregate on here&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Stats-Aggregation-Compute-the-count-min-max-avg-sum-in-one-go"><a href="#Stats-Aggregation-Compute-the-count-min-max-avg-sum-in-one-go" class="headerlink" title="Stats Aggregation: Compute the count, min, max, avg, sum in one go"></a>Stats Aggregation: Compute the count, min, max, avg, sum in one go</h4><p>combine those count,min,max… metric aggregation</p>
<h4 id="Cardinality-Aggregation-Unique-x2F-distinct"><a href="#Cardinality-Aggregation-Unique-x2F-distinct" class="headerlink" title="Cardinality Aggregation(Unique&#x2F;distinct)"></a>Cardinality Aggregation(Unique&#x2F;distinct)</h4><p>It just like <code>disinct</code> keyword in MySQL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET Enter_name_of_the_index_here</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line">  <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Name your aggregations here&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;cardinality&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;field&quot;</span>: <span class="string">&quot;Name the field you want to aggregate on here&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Bucket-Aggregations"><a href="#Bucket-Aggregations" class="headerlink" title="Bucket Aggregations"></a>Bucket Aggregations</h4><p><strong>group different document in the same bucket</strong>.</p>
<p><img src="/elsatic-search.assets/image-20221020133732129.png" alt="image-20221020133732129"></p>
<p>The following are different types of bucket aggregations.</p>
<ul>
<li><p>Date Histogram Aggregation</p>
</li>
<li><p>Histogram Aggregation</p>
</li>
<li><p>Range Aggregation</p>
</li>
<li><p>Terms aggregation</p>
</li>
</ul>
<h4 id="Combined-Aggregations"><a href="#Combined-Aggregations" class="headerlink" title="Combined Aggregations"></a>Combined Aggregations</h4><h2 id="Full-text-query"><a href="#Full-text-query" class="headerlink" title="Full text query"></a>Full text query</h2><p>The match query is a standard query for performing a full text search. This query retrieves documents that contain the search terms. It uses “OR” logic by default, meaning that it will retrieve documents that contain any one of the search terms. The order and the proximity in which the search terms are found(i.e. phrases) are not taken into account.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET Enter_name_of_index_here/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Specify the field you want to search&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;Enter search terms&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Search-phrase"><a href="#Search-phrase" class="headerlink" title="Search phrase"></a>Search phrase</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET news_headlines/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;headline&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;Shape of you&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>The top hit as well as many others in the search results only <strong>contain the search terms “you” and “shape”</strong>. These terms are <strong>not found in the same order</strong> or in proximity to each other as the search terms <strong>“Shape of you”</strong>.</p>
<p>When the match query is used to search for a phrase, it has <strong>high recall</strong> but <strong>low precision</strong> as it returns a lot of loosely related documents.</p>
<h4 id="Searching-for-phrases-using-the-match-phrase-query"><a href="#Searching-for-phrases-using-the-match-phrase-query" class="headerlink" title="Searching for phrases using the match_phrase query"></a>Searching for phrases using the match_phrase query</h4><p><code>match_phrase</code> can improve search precision </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET Enter_name_of_index_here/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_phrase&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Specify the field you want to search&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: <span class="string">&quot;Enter search terms&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<h4 id="Bool-query"><a href="#Bool-query" class="headerlink" title="Bool query"></a>Bool query</h4><p>The bool query retrieves documents matching boolean combinations of other queries</p>
<p>With the bool query, you can combine multiple queries into one request and further specify boolean clauses to narrow down your search results.</p>
<p>There are four clauses to choose from:</p>
<ol>
<li>must</li>
<li>must_not</li>
<li>should</li>
<li>filter</li>
</ol>
<p>You can build combinations of one or more of these clauses. Each clause can contain one or multiple queries that specify the criteria of each clause.</p>
<p>These clauses are optional and can be mixed and matched to cater to your use case. The order in which they appear does not matter either!</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET name_of_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;One or more queries can be specified here. A document MUST match all of these queries to be considered as a hit.&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123;A document must NOT match any of the queries specified here. It it does, it is excluded from the search results.&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;should&quot;</span>: [</span><br><span class="line">        &#123;A document does not have to match any queries specified here. However, it <span class="keyword">if</span> it does match, this document is given a higher score.&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;filter&quot;</span>: [</span><br><span class="line">        &#123;These filters(queries) place documents <span class="keyword">in</span> either <span class="built_in">yes</span> or no category. Ones that fall into the <span class="built_in">yes</span> category are included <span class="keyword">in</span> the hits. &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="A-combination-of-query-and-aggregation-request"><a href="#A-combination-of-query-and-aggregation-request" class="headerlink" title="A combination of query and aggregation request"></a>A combination of query and aggregation request</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET news_headlines/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;match_phrase&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;headline&quot;</span>: <span class="string">&quot;Michelle Obama&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;category&quot;</span>: <span class="string">&quot;POLITICS&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Write Once, Run Anywhere</title>
    <url>/2022/10/16/java-CORA/</url>
    <content><![CDATA[<h1 id="何为”一次编写，导出运行”"><a href="#何为”一次编写，导出运行”" class="headerlink" title="何为”一次编写，导出运行”"></a>何为”一次编写，导出运行”</h1><p>相信学习Java的时候都听过”一次编写，到处运行”这句话，那么它究竟是如何实现的，今天在看周志明老师的《深入理解Java虚拟机》这本书时，终于有了深刻的理解。俗话说好记性不如烂笔头，写下这篇笔记是为了以后查阅。</p>
<p>目前Java的虚拟机在朝着无语言倾向发展，这意味着任何语言都可以在Java虚拟机上运行。Java虚拟机实现语言无关性的关键是</p>
<blockquote>
<p>虚拟机和字节码存储格式(.class)</p>
</blockquote>
<p>这意味着Java虚拟机能够执行任何.class文件，无论这个字节码文件来自何种语言，下图就是一些示例。</p>
<p><img src="/java-CORA.assets/image-20221016003924546.png" alt="image-20221016003924546"></p>
<p>到了这里你可能会感到疑惑，我们的Java源码也是”一次编写，到处运行”啊，为什么说关键在于.class文件呢，</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Distributed lock</title>
    <url>/2022/10/19/distributed-lock/</url>
    <content><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>学习分布式有一个绕不开的知识点就是分布式锁(Distributed Lock), 它的目的只有一个：<strong>确保在多个线程并发时，只有一个线程在同一刻操作这个业务或者说方法、变量。</strong> 这是分布式锁的核心，</p>
<p>对于锁大家肯定不会陌生，在Java中synchronized关键字和ReentrantLock可重入锁在我们的代码中是经常见的，一般我们用其在多线程环境中控制对资源的并发访问，但是随着分布式的快速发展，本地的加锁往往不能满足我们的需要，在我们的分布式环境中上面加锁的方法就会失去作用。于是人们为了在分布式环境中也能实现本地锁的效果，也是纷纷各出其招，今天让我们来聊一聊一般分布式锁实现的套路。</p>
<blockquote>
<p>Java实现的是本地加锁，在分布式环境中，本地加锁不起作用。</p>
</blockquote>
<p>分布式环境下对N的边界检查就不可靠，<strong>因为从redis读的N可能已经是脏数据。传统的加锁的做法（如java的synchronized和Lock）也没用，因为这是分布式环境</strong></p>
<p><strong>分布式锁可以把整个集群就当作是一个应用一样去处理，那么也就需要这个锁，要独立于每一个服务之外，而不是在服务里面</strong>。</p>
<p>首先redis是单线程的，这里的单线程指的是<strong>网络请求模块使用了一个线程</strong>（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p>
<h3 id="常见的分布式锁"><a href="#常见的分布式锁" class="headerlink" title="常见的分布式锁"></a>常见的分布式锁</h3><ol>
<li>MySQL</li>
<li>zookeeper</li>
<li>Redis</li>
</ol>
<p>分布式锁可以基于很多种方式实现，比如zookeeper、redis…。不管哪种方式，他的<strong>基本原理</strong>是不变的：<strong>用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</strong></p>
<h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系。redis的SETNX命令可以方便的实现分布式锁。</p>
<p>setNX（SET if Not eXists）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure>

<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h2 id="参考-reference"><a href="#参考-reference" class="headerlink" title="参考(reference)"></a>参考(reference)</h2><p><a href="https://www.cnblogs.com/JJJ1990/p/10496850.html#!comments">https://www.cnblogs.com/JJJ1990/p/10496850.html#!comments</a></p>
<p><a href="https://juejin.cn/post/6844903688088059912">https://juejin.cn/post/6844903688088059912</a></p>
<p><a href="https://www.cnblogs.com/0201zcr/p/5942748.html">https://www.cnblogs.com/0201zcr/p/5942748.html</a></p>
]]></content>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock in MySQL</title>
    <url>/2022/10/19/mysql-lock/</url>
    <content><![CDATA[<p><img src="/mysql-lock.assets/image-20221019172106982.png" alt="image-20221019172106982"></p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>RDB AND AOF</title>
    <url>/2022/10/19/redis-rdb-aof/</url>
    <content><![CDATA[<p>主要时对Redis设计与实现这本书的整理。</p>
<p>保存的数据类型不同：</p>
<ul>
<li>RDB保存键值对</li>
<li>AOF保存写命令</li>
</ul>
<p><img src="/redis-rdb-aof.assets/image-20221019204706561.png" alt="image-20221019204706561"></p>
<h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>Redis是一个内存数据库，所以它是易失型数据库，在断电或故障的时候数据会丢失, 有些情况下的数据丢失是不能容忍的，所以Redis提供了两种方式来持久化保存。</p>
<h4 id="RDB文件的创建"><a href="#RDB文件的创建" class="headerlink" title="RDB文件的创建"></a>RDB文件的创建</h4><p><strong>RDB文件是一个经过压缩的二进制文件，它可以还原数据库的状态</strong>。</p>
<p><img src="/redis-rdb-aof.assets/image-20221019202547859.png" alt="image-20221019202547859"></p>
<p>有两种创建方式，分别是save和bgsave.</p>
<p>首先是save</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis&gt; save</span><br></pre></td></tr></table></figure>



<p>save命令会阻塞Redis服务器教程，换句话说就是，如果你在将当前数据库状态保存到RDB文件中时，其他的操作都会被阻塞。</p>
<p>第二种是bgsave</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis&gt;bgsave</span><br></pre></td></tr></table></figure>

<p>bgsave顾名思义，就是background save, 它通过调用fork()系统调用创建子进程，然后让子进程去执行dump操作，这样服务器就不会被阻塞了。服务器教程可以继续执行其他操作。</p>
<h4 id="RDB文件的载入"><a href="#RDB文件的载入" class="headerlink" title="RDB文件的载入"></a>RDB文件的载入</h4><p>与RDB文件创建不同，载入时在Redis服务器启动时自动完成的，所以不需要执行命令。只要检测到RDB文件存在，就会自动载入。</p>
<p>启动服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis&gt; redis-server</span><br></pre></td></tr></table></figure>





<h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>上述命令分别表示900秒内有1次修改，300秒内有10次修改，60秒内有10000次修改就自动执行save命令。</p>
<h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同</p>
<p>AOF是通过保存Redis服务器所执行的<code>写命令</code>来记录数据库状态的</p>
<p><img src="/redis-rdb-aof.assets/image-20221019204144090.png" alt="image-20221019204144090"></p>
<p>下面来看个例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis&gt; <span class="built_in">set</span> msg <span class="string">&quot;hello&quot;</span></span><br><span class="line">redis&gt; sadd fruits <span class="string">&quot;apple&quot;</span> <span class="string">&quot;banana&quot;</span> <span class="string">&quot;orange&quot;</span></span><br><span class="line">redis&gt; rpush numbers 128 256 512</span><br></pre></td></tr></table></figure>



<p>RDB持久化保存数据库状态的方法是将msg、fruits、numbers三个键的键值对保存到RDB文件中，</p>
<p>而AOF持久化保存数据库状态的方法则是将服务器执行的SET,SADD,RPUSH三个命令保存到AOF文件中。</p>
<h3 id="AOF实现步骤-3-steps"><a href="#AOF实现步骤-3-steps" class="headerlink" title="AOF实现步骤(3 steps)"></a>AOF实现步骤(3 steps)</h3><p>AOF实现分为三步，命令追加，文件写入，文件同步三步。</p>
<h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾：</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Sentinel</title>
    <url>/2022/10/18/redis-sentinel/</url>
    <content><![CDATA[<p>Redis的主从复制模式下，一旦主节点由于故障不能提供服务，需要人 工将从节点晋升为主节点，同时还要通知应用方更新主节点地址，对于很多 应用场景这种故障处理的方式是无法接受的.</p>
<p><img src="/redis-sentinel.assets/image-20221018175041527.png" alt="image-20221018175041527"></p>
<p>主从复制的问题：(需要手动)</p>
<ul>
<li>一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需 要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整 个过程都需要人工干预</li>
<li>主节点的写能力受到单机的限制。</li>
<li>主节点的存储能力受到单机的限制。</li>
</ul>
<p><strong>&#x3D;&#x3D;其中第一个问题就是Redis的高可用问题  第二、三个问题属于Redis的分布式问题&#x3D;&#x3D;</strong></p>
<p>手动配置完还有这些问题：</p>
<ul>
<li><p>第一，判断节点不可达的机制是否健全和标 准。</p>
</li>
<li><p>第二，如果有多个从节点，怎样保证只有一个被晋升为主节点。</p>
</li>
<li><p>第三， 通知客户端新的主节点机制是否足够健壮。</p>
<p>Redis Sentinel正是用于解决这些 问题。</p>
</li>
</ul>
<h2 id="Redis-Sentinel的高可用性"><a href="#Redis-Sentinel的高可用性" class="headerlink" title="Redis Sentinel的高可用性"></a>Redis Sentinel的高可用性</h2><p>当主节点出现故障时，Redis Sentinel能自动完成故障发现和故障转移， 并通知应用方，从而实现真正的高可用。</p>
<p>Redis Sentinel是一个分布式架构，其中包含若干个Sentinel节点和Redis 数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当 它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还 会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可 达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会 将这个变化实时通知给Redis应用方。整个过程完全是自动的，不需要人工 来介入，所以这套方案很有效地解决了Redis的高可用问题。</p>
<blockquote>
<p>Redis Sentinel与Redis主从复制模式只是多了若干Sentinel 节点，所以Redis Sentinel并没有针对Redis节点做了特殊处理，这里是很多开发和运维人员容易混淆的。</p>
</blockquote>
<p><img src="/redis-sentinel.assets/image-20221018175758325.png" alt="image-20221018175758325"></p>
<p>从逻辑架构上看，Sentinel节点集合会定期对所有节点进行监控，特别 是对主节点的故障实现自动转移。</p>
<h2 id="Redis-Sentinel-功能"><a href="#Redis-Sentinel-功能" class="headerlink" title="Redis Sentinel 功能"></a>Redis Sentinel 功能</h2><ol>
<li>监控：Sentinel节点会定期检测Redis数据节点、其余Sentinel节点是否 可达。</li>
<li>通知：Sentinel节点会将故障转移的结果通知给应用方。</li>
<li>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关 系。</li>
<li>配置提供者：在Redis Sentinel结构中，客户端在初始化的时候连接的 是Sentinel节点集合，从中获取主节点信息。</li>
</ol>
<p><strong>Redis Sentinel包含了若个Sentinel节点，这样做也带来了两个好处</strong>：</p>
<ul>
<li>对于节点的故障判断是由多个Sentinel节点共同完成，这样可以有效地 防止误判。</li>
<li>Sentinel节点集合是由若干个Sentinel节点组成的，这样即使个别Sentinel 节点不可用，整个Sentinel节点集合依然是健壮的。</li>
</ul>
<p><strong>&#x3D;&#x3D;但是Sentinel节点本身就是独立的Redis节点，只不过它们有一些特殊， 它们不存储数据，只支持部分命令&#x3D;&#x3D;</strong></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>拓扑结构</p>
<p><img src="/redis-sentinel.assets/image-20221018180354115.png" alt="image-20221018180354115"></p>
<p><img src="/redis-sentinel.assets/image-20221018180339962.png" alt="image-20221018180339962"></p>
<h3 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h3><p>配置文件中配置主节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-6379.conf</span><br><span class="line"></span><br><span class="line">port 6379</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">logfile <span class="string">&quot;6379.log&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump-6379.rdb&quot;</span></span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/opt/soft/redis/data/&quot;</span></span><br></pre></td></tr></table></figure>



<p>启动主节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br></pre></td></tr></table></figure>



<p>使用ping命令查看是否启动成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>





<h3 id="从节点"><a href="#从节点" class="headerlink" title="从节点"></a>从节点</h3><p>配置文件中配置从节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-6380.conf</span><br><span class="line"></span><br><span class="line">port 6380</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">logfile <span class="string">&quot;6380.log&quot;</span></span><br><span class="line">dbfilename <span class="string">&quot;dump-6380.rdb&quot;</span></span><br><span class="line"><span class="built_in">dir</span> <span class="string">&quot;/opt/soft/redis/data/&quot;</span></span><br><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>



<p>启动两个从节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server redis-6380.conf</span><br><span class="line">redis-server redis-6381.conf</span><br></pre></td></tr></table></figure>



<p>验证是否启动成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6380 ping</span><br><span class="line">PONG</span><br><span class="line">$ redis-cli -h 127.0.0.1 -p 6381 ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>



<p>查看复制关系<code>info replication </code></p>
<p>主节点查看复制关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6379 info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=281,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=281,lag=0</span><br></pre></td></tr></table></figure>



<p>从节点查看复制关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6380 info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br></pre></td></tr></table></figure>



<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>方法跟配置集群类似，首先是配置文件里添加配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-sentinel-26379.conf</span><br><span class="line"></span><br><span class="line">port 26379</span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line">logfile <span class="string">&quot;26379.log&quot;</span></span><br><span class="line"><span class="built_in">dir</span> /opt/soft/redis/data</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>启动Sentinel</p>
<p>方法一：<code>redis-sentinel</code>命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-sentinel redis-sentinel-26379.conf</span><br></pre></td></tr></table></figure>

<p>方法二：使用redis-server命令加–sentinel参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server redis-sentinel-26379.conf --sentinel</span><br></pre></td></tr></table></figure>



<p>​	查看启动状态</p>
<p>Sentinel节点本质上是一个特殊的Redis节点，所以也可以通过info命令 来查询它的相关信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 26379 info Sentinel</span><br><span class="line"><span class="comment"># Sentinel</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure>



<p>拓扑图</p>
<p><img src="/redis-sentinel.assets/image-20221019143006210.png" alt="image-20221019143006210"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>三个定时任务</p>
</blockquote>
<ol>
<li>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取 最新的拓扑结构</li>
<li>每隔2秒，每个Sentinel节点会向Redis数据节点的__sentinel__：hello 频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息 （如图9-27所示），同时每个Sentinel节点也会订阅该频道，来了解其他 Sentinel节点以及它们对主节点的判断</li>
<li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点 发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。</li>
</ol>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Cluster</title>
    <url>/2022/10/18/redis-cluster/</url>
    <content><![CDATA[<h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到 其他机器，满足故障恢复和负载均衡等需求。Redis也是如此，它为我们提 供了复制功能，实现了相同数据的多个Redis副本</p>
<p><img src="/redis-cluster.assets/image-20221018204041498.png" alt="image-20221018204041498"></p>
<h2 id="建立复制Replication"><a href="#建立复制Replication" class="headerlink" title="建立复制Replication"></a>建立复制Replication</h2><p>复制的数据流是<strong>单向的</strong>，只能由主节点复制到从节 点。<strong>配置复制的方式有以下三种</strong></p>
<ol>
<li>在配置文件中加入slaveof{masterHost}{masterPort}随Redis启动生 效。</li>
<li>在redis-server启动命令后加入–slaveof{masterHost}{masterPort}生 效。</li>
<li>直接使用命令：slaveof{masterHost}{masterPort}生效。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt;slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>slaveof配置都是在从节点发起，这时6379作为主节点，6380作为从节 点。</p>
<p>针对主节点6379的任何修改都可以 同步到从节点6380中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt;<span class="built_in">set</span> hello redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;get hello</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6380&gt;get hello</span><br><span class="line"><span class="string">&quot;redis&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/redis-cluster.assets/image-20221018171333136.png" alt="image-20221018171333136"></p>
<p><strong>slaveof本身是异步命令，执行slaveof命令时，节点只保存主节点信息后 返回，后续复制流程在节点内部异步执行</strong></p>
<p>可以使用<code>info replication</code>查看复制消息</p>
<h2 id="断开复制"><a href="#断开复制" class="headerlink" title="断开复制"></a>断开复制</h2><p>slaveof命令不但可以建立复制，还可以在从节点执行<code>slaveof no one</code>来断 开与主节点复制关系。</p>
<p><img src="/redis-cluster.assets/image-20221018172102143.png" alt="image-20221018172102143"></p>
<p>断开复制主要流程：</p>
<p>1）断开与主节点复制关系。 </p>
<p>2）从节点晋升为主节点。</p>
<p>通过slaveof命令还可以实现切主操作，所谓切主是指把当前从节点对主 节点的复制切换到另一个主节点。执行slaveof{newMasterIp} {newMasterPort}命令即可</p>
<h2 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h2><p>默认情况下，从节点使用<code>slave-read-only=yes</code>配置为只读模式。</p>
<p>修改 从节点会造成主从数据不一致。因此建议线上不要修改从节点的只读模式</p>
<h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><p>Redis的复制拓扑结构可以支持单层或多层复制关系，根据拓扑复杂性 可以分为以下三种：<strong>一主一从、一主多从、树状主从结构</strong>.</p>
<h4 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h4><p>一主一从结构是最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持. 当应用写命令并发量较高且需要持久化时，可以只在从节点上开启AOF，这样既保证数据安全性同时也避免了持久化对主节点的性能干扰</p>
<p>但需要注意的是，当主节点关闭持久化功能时， 如果主节点脱机要避免自动重启操作。因为主节点之前没有开启持久化功能 自动重启后数据集为空，这时从节点如果继续复制主节点会导致从节点数据 也被清空的情况，丧失了持久化的意义。安全的做法是在从节点上执行 slaveof no one断开与主节点的复制关系，再重启主节点从而避免这一问题</p>
<p><img src="/redis-cluster.assets/image-20221018172642481.png" alt="image-20221018172642481"></p>
<h4 id="一主多从结构"><a href="#一主多从结构" class="headerlink" title="一主多从结构"></a>一主多从结构</h4><p>一主多从结构（又称为星形拓扑结构）使得应用端可以利用多个从节点 实现<strong>读写分离</strong> </p>
<p>对于读占比较大的场景，可以把读命令发送到 从节点来分担主节点压力。</p>
<p>keys、sort等，可以在其中一台从节点上执行，防止慢查询对 主节点造成阻塞从而影响线上服务的稳定性。对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加 重了主节点的负载影响服务稳定性。</p>
<p><img src="/redis-cluster.assets/image-20221018172827462.png" alt="image-20221018172827462"></p>
<h4 id="树状主从结构"><a href="#树状主从结构" class="headerlink" title="树状主从结构"></a>树状主从结构</h4><p>树状主从结构（又称为树状拓扑结构）使得从节点不但可以复制主节点 数据，同时可以作为其他从节点的主节点继续向下层复制.</p>
<p>通过引入复制中 间层，可以有效降低主节点负载和需要传送给从节点的数据量</p>
<p>当主节点需要挂载多个从节点时为了 避免对主节点的性能干扰，可以采用树状主从结构降低主节点压力.</p>
<p><img src="/redis-cluster.assets/image-20221018173000882.png" alt="image-20221018173000882"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>复制有六步</p>
<p><img src="/redis-cluster.assets/image-20221019114052698.png" alt="image-20221019114052698"></p>
<h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p>Redis在2.8及以上版本使用psync命令完成主从数据同步，同步过程分 为：全量复制和部分复制。</p>
<blockquote>
<p>psync命令完成主从数据同步</p>
</blockquote>
<p>运行psync需要下列组件支持：</p>
<p>Every Redis master has a replication ID: it is a large pseudo random string that marks a given story of the dataset. Each master also takes an offset that increments for every byte of replication stream that it is produced to be sent to replicas, to update the state of the replicas with the new changes modifying the dataset. The replication offset is incremented even if no replica is actually connected, so basically every given pair of:</p>
<ol>
<li>主从节点各自复制偏移量</li>
<li>主节点复制积压缓冲区。</li>
<li>主节点运行id。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Replication ID, offset</span><br></pre></td></tr></table></figure>

<p>Identifies an exact version of the dataset of a master.</p>
<h5 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h5><p>一般用于初次复制场景，Redis早期支持的复制功能只有全 量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会 对主从节点和网络造成很大的开销。</p>
<h5 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h5><p>用于处理在主从复制中因网络闪断等原因造成的数据丢失 场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据 给从节点。因为补发的数据远远小于全量数据，可以有效避免全量复制的过 高开销。</p>
<h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><p>主节点不但负责数据读写，还负责把写命令同步给从节点。写命令的发 送过程是异步完成，也就是说主节点自身处理完写命令后直接返回给客户 端，并不等待从节点复制完成</p>
<p><img src="/redis-cluster.assets/image-20221018173339686.png" alt="image-20221018173339686"></p>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h2><p>分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的 问题，即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。</p>
<p>常见的分区规则有哈希分区和顺序分区两种</p>
<p><img src="/redis-cluster.assets/image-20221019143356719.png" alt="image-20221019143356719"></p>
<p>由于<strong>Redis Cluster采用哈希分区规则，这里我们重点讨论哈希分区，常见的哈希分区规则有几种</strong>：</p>
<p><img src="/redis-cluster.assets/image-20221019150254824.png" alt="image-20221019150254824"></p>
<h3 id="节点取余分区"><a href="#节点取余分区" class="headerlink" title="节点取余分区"></a>节点取余分区</h3><p>使用特定的数据，如Redis的键或用户ID，再根据节点数量N使用公式： hash（key）%N计算出哈希值，用来决定数据映射到哪一个节点上。这种方 案存在一个问题：当节点数量变化时，如扩容或收缩节点，数据节点映射关 系需要重新计算，会导致数据的重新迁移。</p>
<p><img src="/redis-cluster.assets/image-20221019150439049.png" alt="image-20221019150439049"></p>
<h3 id="一致性hash分区"><a href="#一致性hash分区" class="headerlink" title="一致性hash分区"></a>一致性hash分区</h3><p>一致性哈希分区（Distributed Hash Table）实现思路是为系统中每个节 点分配一个token，范围一般在0~2 32，这些token构成一个哈希环。数据读写 执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于 等于该哈希值的token节点</p>
<p><img src="/redis-cluster.assets/image-20221019150416802.png" alt="image-20221019150416802"></p>
<p>这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中 相邻的节点，对其他节点无影响</p>
<p>正因为一致性哈希分区的这些缺点，一些分布式系统采用虚拟槽对一致性哈希进行改进，比如Dynamo系统。</p>
<h3 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h3><p>​	虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有 数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。</p>
<p>这个范围 一般远远大于节点数，比如Redis Cluster槽范围是0~16383。槽是集群内数据 管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集 群扩展。每个节点会负责一定数量的槽。</p>
<p> 如在Redis中，假设有5个节点，每个节点平均负责3276个槽。</p>
<p><img src="/redis-cluster.assets/image-20221019150926737.png" alt="image-20221019150926737"></p>
<p><img src="/redis-cluster.assets/image-20221019151002830.png" alt="image-20221019151002830"></p>
<p>(1) 解耦数据和节点之间的关系，简化了节点的扩容和收缩。<br>(2) 解决了普通一致性哈希分区只有少量节点负载不均衡问题。<br>(3) 支持节点、槽、键之间的映射查询，用于数据路由。</p>
<h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><h3 id="节点握手"><a href="#节点握手" class="headerlink" title="节点握手"></a>节点握手</h3><p>节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信， 达到感知对方的过程。</p>
<p><img src="/redis-cluster.assets/image-20221019151738462.png" alt="image-20221019151738462"></p>
<p>cluster meet命令是一个异步命令，执行之后立刻返回。内部发 起与目标节点进行握手通信</p>
<h3 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h3><p>通过 cluster addslots命令为节点分配槽。这里利用bash特性批量设置槽（slots）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5461&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6380 cluster addslots &#123;5462...10922&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6381 cluster addslots &#123;10923...16383&#125;</span><br></pre></td></tr></table></figure>







<p>使用cluster replicate{nodeId}命令让一个节点成为从节点。其中命令执行必须在对应的 从节点上执行，nodeId是要复制主节点的节点ID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6382&gt;cluster replicate cfb28ef1deee4e0fa78da86abe5d24566744411e</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6383&gt;cluster replicate 8e41673d59c9568aa9d29fb174ce733345b3e8f1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6384&gt;cluster replicate 40b8d09d44294d2e23c7c768efc8fcd153446746</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>





<h2 id="集群伸缩-Scaling"><a href="#集群伸缩-Scaling" class="headerlink" title="集群伸缩(Scaling)"></a>集群伸缩(Scaling)</h2><p>Redis集群提供了灵活的节点扩容和收缩方案。<strong>在不影响集群对外服务 的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容</strong>.</p>
<p><img src="/redis-cluster.assets/image-20221019154018133.png" alt="image-20221019154018133"></p>
<h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><p>1）准备新节点。 </p>
<p>2）加入集群。 </p>
<p>3）迁移槽和数据。</p>
<p>需要提前准备好新节点并运行在集群模式下，新节点建议跟集群内的节 点配置保持一致，便于管理统一。准备好配置后启动两个节点命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-server conf/redis-6385.conf</span><br><span class="line">redis-server conf/redis-6386.conf</span><br></pre></td></tr></table></figure>

<p>启动后的新节点作为<strong>孤儿节点</strong>运行，并没有其他节点与之通信</p>
<p><img src="/redis-cluster.assets/image-20221019154404912.png" alt="image-20221019154404912"></p>
<p>新节点依然采用cluster meet命令加入到现有集群中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster meet 127.0.0.1 6385</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 127.0.0.1 6386</span><br></pre></td></tr></table></figure>



<p><img src="/redis-cluster.assets/image-20221019154443120.png" alt="image-20221019154443120"></p>
<p>集群内新旧节点经过一段时间的ping&#x2F;pong消息通信之后，所有节点会发 现新节点并将它们的状态保存到本地</p>
]]></content>
      <categories>
        <category>Backend</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>安装VirtualBox和vagrant中遇到的问题</title>
    <url>/2022/10/24/win-services/</url>
    <content><![CDATA[<h2 id="the-specified-service-has-been-marked-for-deletion"><a href="#the-specified-service-has-been-marked-for-deletion" class="headerlink" title="the specified service has been marked for deletion"></a>the specified service has been marked for deletion</h2><h2 id="第一个：the-specified-service-has-been-marked-for-deletion"><a href="#第一个：the-specified-service-has-been-marked-for-deletion" class="headerlink" title="第一个：the specified service has been marked for deletion"></a>第一个：the specified service has been marked for deletion</h2><p>今天在重新安装virtualbox的时候发现了一个错误“the specified service has been marked for deletion”, 主要是因为之前的virtualbox打不开了，一开始以为是服务没打开，点击后就出现了这个错误，后来发现只需要重新打开services面板这个错误就会消失。</p>
<h2 id="第二个：-No-usable-default-provider-could-be-found-for-your-system-Vagrant-relies-on"><a href="#第二个：-No-usable-default-provider-could-be-found-for-your-system-Vagrant-relies-on" class="headerlink" title="第二个： No usable default provider could be found for your system. Vagrant relies on"></a>第二个： No usable default provider could be found for your system. Vagrant relies on</h2><p>这个问题是vagrant的版本和virtualbox的版本不兼容导致的，我是将virtualbox卸载，然后版本回退到跟vagrant兼容的版本。</p>
<h2 id="第三个：-There-was-an-error-while-executing-VBoxManage-a-CLI…"><a href="#第三个：-There-was-an-error-while-executing-VBoxManage-a-CLI…" class="headerlink" title="第三个： There was an error while executing VBoxManage, a CLI….."></a>第三个： There was an error while executing <code>VBoxManage</code>, a CLI…..</h2><p>参照<a href="https://github.com/sebaux">@sebaux</a>这位前辈的方法，成功解决</p>
<p>连接如下：<a href="https://github.com/hashicorp/vagrant/issues/9318">https://github.com/hashicorp/vagrant/issues/9318</a></p>
<p>需要注意的是这位前辈提供给我们的是virtualbox默认安装地址，如果你修改了默认安装地址的话，你需要到自己的安装目录下寻找**<code>VBoxDrv.inf</code>**这个文件。</p>
<h2 id="第四个：-Call-to-WHvSetupPartition-failed-ERROR-SUCCESS-Last-x3D-0xc000000d-x2F-87-VERR-NEM-VM。。。。"><a href="#第四个：-Call-to-WHvSetupPartition-failed-ERROR-SUCCESS-Last-x3D-0xc000000d-x2F-87-VERR-NEM-VM。。。。" class="headerlink" title="第四个： [Call to WHvSetupPartition failed: ERROR_SUCCESS (Last&#x3D;0xc000000d&#x2F;87) (VERR_NEM_VM。。。。"></a>第四个： [Call to WHvSetupPartition failed: ERROR_SUCCESS (Last&#x3D;0xc000000d&#x2F;87) (VERR_NEM_VM。。。。</h2><p>首先打开命令行，然后运行下面的命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype off</span><br></pre></td></tr></table></figure>

<p>然后重启电脑即可。</p>
]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>reactive</title>
    <url>/2022/10/31/reactive/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>WSL</title>
    <url>/2022/10/28/wsl/</url>
    <content><![CDATA[<h2 id="如何在WSL中访问到Windows的文件和目录"><a href="#如何在WSL中访问到Windows的文件和目录" class="headerlink" title="如何在WSL中访问到Windows的文件和目录"></a>如何在WSL中访问到Windows的文件和目录</h2><p>只需要使用命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/d</span><br></pre></td></tr></table></figure>

<p>上面的命令指的是切换到Windows的D盘根目录，如果你要切换到C盘</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/c</span><br></pre></td></tr></table></figure>



<p>甚至可以直接到达目标目录</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/d/path_to_your_target_directory/</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
</search>
